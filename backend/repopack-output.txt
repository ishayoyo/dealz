This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repopack on: 2024-09-14T19:06:49.822Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repopack's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

For more information about Repopack, visit: https://github.com/yamadashy/repopack

================================================================
Repository Structure
================================================================
.gitignore
package.json
src/app.js
src/config/config.js
src/controllers/adminController.js
src/controllers/commentController.js
src/controllers/dealController.js
src/controllers/userController.js
src/middleware/auth.js
src/middleware/isAdmin.js
src/middleware/rateLimit.js
src/models/Comment.Model.js
src/models/Deal.Model.js
src/models/Follow.Model.js
src/models/User.Model.js
src/models/Vote.Model.js
src/routes/api/v1/Admin.Route.js
src/routes/api/v1/Comment.Route.js
src/routes/api/v1/Deal.Route.js
src/routes/api/v1/index.js
src/routes/api/v1/User.Route.js
src/server.js
src/services/imageFetcherService.js
src/testImageFetcher.js
src/utils/appError.js
src/utils/catchAsync.js

================================================================
Repository Files
================================================================

================
File: .gitignore
================
node_modules/
.env

================
File: package.json
================
{
  "name": "backend",
  "version": "1.0.0",
  "main": "src/server.js",
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1",
    "start": "node src/server.js",
    "dev": "nodemon src/server.js"
  },
  "keywords": [],
  "author": "",
  "license": "ISC",
  "dependencies": {
    "@azure/cognitiveservices-imagesearch": "^3.0.1",
    "@azure/ms-rest-azure-js": "^2.1.0",
    "axios": "^1.7.7",
    "bcryptjs": "^2.4.3",
    "cheerio": "^1.0.0",
    "compression": "^1.7.4",
    "cors": "^2.8.5",
    "dotenv": "^16.4.5",
    "express": "^4.21.0",
    "express-mongo-sanitize": "^2.2.0",
    "express-rate-limit": "^7.4.0",
    "helmet": "^7.1.0",
    "hpp": "^0.2.3",
    "ioredis": "^5.4.1",
    "jsonwebtoken": "^9.0.2",
    "mongoose": "^8.6.2",
    "morgan": "^1.10.0",
    "puppeteer": "^23.3.0",
    "puppeteer-extra": "^3.3.6",
    "puppeteer-extra-plugin-stealth": "^2.11.2",
    "xss-clean": "^0.1.4"
  },
  "devDependencies": {
    "nodemon": "^3.1.4"
  },
  "description": ""
}

================
File: src/app.js
================
const express = require('express');
const dealRoutes = require('./routes/api/v1/Deal.Route');

const app = express();

app.use(express.json());
app.use('/api/v1/deals', dealRoutes);

// ... other middleware and error handling

module.exports = app;

================
File: src/config/config.js
================
require('dotenv').config();

module.exports = {
  port: process.env.PORT || 5000,
  mongoUri: process.env.MONGO_URI,
  // Add other configuration variables as needed
};

================
File: src/controllers/adminController.js
================
const User = require('../models/User.Model');
const Deal = require('../models/Deal.Model');
const Comment = require('../models/Comment.Model');
const AppError = require('../utils/appError');
const catchAsync = require('../utils/catchAsync');

exports.getUsers = catchAsync(async (req, res, next) => {
  const users = await User.find().select('-password');

  res.status(200).json({
    status: 'success',
    results: users.length,
    data: { users }
  });
});

exports.updateUser = catchAsync(async (req, res, next) => {
  const user = await User.findByIdAndUpdate(req.params.id, req.body, {
    new: true,
    runValidators: true
  }).select('-password');

  if (!user) {
    return next(new AppError('No user found with that ID', 404));
  }

  res.status(200).json({
    status: 'success',
    data: { user }
  });
});

exports.deleteUser = catchAsync(async (req, res, next) => {
  const user = await User.findByIdAndDelete(req.params.id);

  if (!user) {
    return next(new AppError('No user found with that ID', 404));
  }

  res.status(204).json({
    status: 'success',
    data: null
  });
});

exports.getDeals = catchAsync(async (req, res, next) => {
  const deals = await Deal.find().populate('user', 'username');

  res.status(200).json({
    status: 'success',
    results: deals.length,
    data: { deals }
  });
});

exports.updateDeal = catchAsync(async (req, res, next) => {
  const deal = await Deal.findByIdAndUpdate(req.params.id, req.body, {
    new: true,
    runValidators: true
  });

  if (!deal) {
    return next(new AppError('No deal found with that ID', 404));
  }

  res.status(200).json({
    status: 'success',
    data: { deal }
  });
});

exports.deleteDeal = catchAsync(async (req, res, next) => {
  const deal = await Deal.findByIdAndDelete(req.params.id);

  if (!deal) {
    return next(new AppError('No deal found with that ID', 404));
  }

  res.status(204).json({
    status: 'success',
    data: null
  });
});

exports.getStats = catchAsync(async (req, res, next) => {
  const userCount = await User.countDocuments();
  const dealCount = await Deal.countDocuments();
  const commentCount = await Comment.countDocuments();

  res.status(200).json({
    status: 'success',
    data: {
      userCount,
      dealCount,
      commentCount
    }
  });
});

// More admin methods as needed

================
File: src/controllers/commentController.js
================
const Comment = require('../models/Comment.Model');
const Deal = require('../models/Deal.Model');
const AppError = require('../utils/appError');
const catchAsync = require('../utils/catchAsync');

exports.addComment = catchAsync(async (req, res, next) => {
  const { dealId } = req.params;
  const { content } = req.body;

  const deal = await Deal.findById(dealId);

  if (!deal) {
    return next(new AppError('No deal found with that ID', 404));
  }

  const comment = await Comment.create({
    content,
    user: req.user.id,
    deal: dealId
  });

  res.status(201).json({
    status: 'success',
    data: { comment }
  });
});

exports.updateComment = catchAsync(async (req, res, next) => {
  const comment = await Comment.findById(req.params.id);

  if (!comment) {
    return next(new AppError('No comment found with that ID', 404));
  }

  if (comment.user.toString() !== req.user.id && req.user.role !== 'admin') {
    return next(new AppError('You do not have permission to perform this action', 403));
  }

  comment.content = req.body.content;
  await comment.save();

  res.status(200).json({
    status: 'success',
    data: { comment }
  });
});

exports.deleteComment = catchAsync(async (req, res, next) => {
  const comment = await Comment.findById(req.params.id);

  if (!comment) {
    return next(new AppError('No comment found with that ID', 404));
  }

  if (comment.user.toString() !== req.user.id && req.user.role !== 'admin') {
    return next(new AppError('You do not have permission to perform this action', 403));
  }

  await comment.remove();

  res.status(204).json({
    status: 'success',
    data: null
  });
});

// More methods as needed

================
File: src/controllers/dealController.js
================
const Deal = require('../models/Deal.Model');
const User = require('../models/User.Model');
const AppError = require('../utils/appError');
const catchAsync = require('../utils/catchAsync');

exports.getDeals = catchAsync(async (req, res, next) => {
  const page = parseInt(req.query.page, 10) || 1;
  const limit = parseInt(req.query.limit, 10) || 10;
  const skip = (page - 1) * limit;

  const deals = await Deal.find({ status: 'active' })
    .sort('-createdAt')
    .skip(skip)
    .limit(limit)
    .populate('user', 'username profilePicture');

  const total = await Deal.countDocuments({ status: 'active' });

  res.status(200).json({
    status: 'success',
    results: deals.length,
    total,
    page,
    totalPages: Math.ceil(total / limit),
    data: { deals }
  });
});

exports.createDeal = catchAsync(async (req, res, next) => {
  const { title, description, price, originalPrice, url, store, category, tags } = req.body;

  const deal = await Deal.create({
    title,
    description,
    price,
    originalPrice,
    url,
    store,
    category,
    tags,
    user: req.user.id
  });

  res.status(201).json({
    status: 'success',
    data: { deal }
  });
});

exports.getDeal = catchAsync(async (req, res, next) => {
  const deal = await Deal.findById(req.params.id)
    .populate('user', 'username profilePicture')
    .populate({
      path: 'comments',
      populate: { path: 'user', select: 'username profilePicture' }
    });

  if (!deal) {
    return next(new AppError('No deal found with that ID', 404));
  }

  res.status(200).json({
    status: 'success',
    data: { deal }
  });
});

exports.updateDeal = catchAsync(async (req, res, next) => {
  const deal = await Deal.findById(req.params.id);

  if (!deal) {
    return next(new AppError('No deal found with that ID', 404));
  }

  if (deal.user.toString() !== req.user.id && req.user.role !== 'admin') {
    return next(new AppError('You do not have permission to perform this action', 403));
  }

  Object.assign(deal, req.body);
  await deal.save();

  res.status(200).json({
    status: 'success',
    data: { deal }
  });
});

exports.deleteDeal = catchAsync(async (req, res, next) => {
  const deal = await Deal.findById(req.params.id);

  if (!deal) {
    return next(new AppError('No deal found with that ID', 404));
  }

  if (deal.user.toString() !== req.user.id && req.user.role !== 'admin') {
    return next(new AppError('You do not have permission to perform this action', 403));
  }

  await deal.deleteOne();  // Changed from remove() to deleteOne()

  res.status(204).json({
    status: 'success',
    data: null
  });
});

exports.voteDeal = catchAsync(async (req, res, next) => {
  const { id } = req.params;
  const { value } = req.body;

  const deal = await Deal.findById(id);

  if (!deal) {
    return next(new AppError('No deal found with that ID', 404));
  }

  const existingVote = deal.votes.find(vote => vote.user.toString() === req.user.id);

  if (existingVote) {
    existingVote.vote = value;
  } else {
    deal.votes.push({ user: req.user.id, vote: value });
  }

  await deal.save();

  res.status(200).json({
    status: 'success',
    data: { voteCount: deal.voteCount }
  });
});

exports.addComment = catchAsync(async (req, res, next) => {
  const { id } = req.params;
  const { content } = req.body;

  const deal = await Deal.findById(id);

  if (!deal) {
    return next(new AppError('No deal found with that ID', 404));
  }

  const comment = {
    content,
    user: req.user.id,
    createdAt: new Date()
  };

  deal.comments.push(comment);
  await deal.save();

  res.status(201).json({
    status: 'success',
    data: { comment }
  });
});

exports.getDealComments = catchAsync(async (req, res, next) => {
  const deal = await Deal.findById(req.params.id).populate({
    path: 'comments',
    populate: { path: 'user', select: 'username profilePicture' }
  });

  if (!deal) {
    return next(new AppError('No deal found with that ID', 404));
  }

  res.status(200).json({
    status: 'success',
    data: { comments: deal.comments }
  });
});

exports.searchDeals = catchAsync(async (req, res, next) => {
  // TODO: Implement search logic
  res.status(501).json({ message: 'searchDeals not implemented yet' });
});

exports.getCategories = catchAsync(async (req, res, next) => {
  // TODO: Implement get categories logic
  res.status(501).json({ message: 'getCategories not implemented yet' });
});

exports.getStores = catchAsync(async (req, res, next) => {
  // TODO: Implement get stores logic
  res.status(501).json({ message: 'getStores not implemented yet' });
});

exports.getTrendingDeals = catchAsync(async (req, res, next) => {
  // TODO: Implement get trending deals logic
  res.status(501).json({ message: 'getTrendingDeals not implemented yet' });
});

exports.getExpiringSoonDeals = catchAsync(async (req, res, next) => {
  // TODO: Implement get expiring soon deals logic
  res.status(501).json({ message: 'getExpiringSoonDeals not implemented yet' });
});

================
File: src/controllers/userController.js
================
const User = require('../models/User.Model');
const jwt = require('jsonwebtoken');
const bcrypt = require('bcryptjs');
const { promisify } = require('util');

// Helper function to create JWT token
const signToken = id => {
  return jwt.sign({ id }, process.env.JWT_SECRET, {
    expiresIn: process.env.JWT_EXPIRES_IN
  });
};

exports.register = async (req, res) => {
  try {
    const { username, email, password } = req.body;

    // Check if user already exists
    const existingUser = await User.findOne({ $or: [{ email }, { username }] });
    if (existingUser) {
      return res.status(400).json({ message: 'User already exists' });
    }

    // Create new user
    const newUser = await User.create({
      username,
      email,
      password
    });

    // Generate token
    const token = signToken(newUser._id);

    res.status(201).json({
      status: 'success',
      token,
      data: {
        user: {
          id: newUser._id,
          username: newUser.username,
          email: newUser.email
        }
      }
    });
  } catch (error) {
    res.status(500).json({ message: 'Error registering new user', error: error.message });
  }
};

exports.login = async (req, res) => {
  try {
    const { email, password } = req.body;

    // Check if email and password exist
    if (!email || !password) {
      return res.status(400).json({ message: 'Please provide email and password' });
    }

    // Check if user exists && password is correct
    const user = await User.findOne({ email }).select('+password');
    if (!user || !(await user.comparePassword(password))) {
      return res.status(401).json({ message: 'Incorrect email or password' });
    }

    // If everything ok, send token to client
    const token = signToken(user._id);

    res.status(200).json({
      status: 'success',
      token
    });
  } catch (error) {
    res.status(500).json({ message: 'Error logging in', error: error.message });
  }
};

exports.logout = (req, res) => {
  // In a stateless JWT setup, logout is typically handled client-side
  // by removing the token. Here we just send a success response.
  res.status(200).json({ status: 'success' });
};

exports.getCurrentUser = async (req, res) => {
  try {
    const user = await User.findById(req.user.id);
    res.status(200).json({
      status: 'success',
      data: { user }
    });
  } catch (error) {
    res.status(500).json({ message: 'Error fetching current user', error: error.message });
  }
};

exports.updateCurrentUser = async (req, res) => {
  try {
    const updatedUser = await User.findByIdAndUpdate(req.user.id, req.body, {
      new: true,
      runValidators: true
    });

    res.status(200).json({
      status: 'success',
      data: { user: updatedUser }
    });
  } catch (error) {
    res.status(500).json({ message: 'Error updating user', error: error.message });
  }
};

// Implement other controller methods (getUser, getUserDeals, getUserFollowers, getUserFollowing, followUser, unfollowUser, forgotPassword, resetPassword, verifyEmail) here...

exports.getUser = async (req, res) => {
  try {
    // TODO: Implement getUser logic
    res.status(501).json({ message: 'getUser not implemented yet' });
  } catch (error) {
    res.status(500).json({ message: 'Error fetching user', error: error.message });
  }
};

exports.getUserDeals = async (req, res) => {
  try {
    // TODO: Implement getUserDeals logic
    res.status(501).json({ message: 'getUserDeals not implemented yet' });
  } catch (error) {
    res.status(500).json({ message: 'Error fetching user deals', error: error.message });
  }
};

exports.getUserFollowers = async (req, res) => {
  try {
    // TODO: Implement getUserFollowers logic
    res.status(501).json({ message: 'getUserFollowers not implemented yet' });
  } catch (error) {
    res.status(500).json({ message: 'Error fetching user followers', error: error.message });
  }
};

exports.getUserFollowing = async (req, res) => {
  try {
    // TODO: Implement getUserFollowing logic
    res.status(501).json({ message: 'getUserFollowing not implemented yet' });
  } catch (error) {
    res.status(500).json({ message: 'Error fetching user following', error: error.message });
  }
};

exports.followUser = async (req, res) => {
  try {
    // TODO: Implement followUser logic
    res.status(501).json({ message: 'followUser not implemented yet' });
  } catch (error) {
    res.status(500).json({ message: 'Error following user', error: error.message });
  }
};

exports.unfollowUser = async (req, res) => {
  try {
    // TODO: Implement unfollowUser logic
    res.status(501).json({ message: 'unfollowUser not implemented yet' });
  } catch (error) {
    res.status(500).json({ message: 'Error unfollowing user', error: error.message });
  }
};

exports.forgotPassword = async (req, res) => {
  try {
    // TODO: Implement forgotPassword logic
    res.status(501).json({ message: 'forgotPassword not implemented yet' });
  } catch (error) {
    res.status(500).json({ message: 'Error processing forgot password request', error: error.message });
  }
};

exports.resetPassword = async (req, res) => {
  try {
    // TODO: Implement resetPassword logic
    res.status(501).json({ message: 'resetPassword not implemented yet' });
  } catch (error) {
    res.status(500).json({ message: 'Error resetting password', error: error.message });
  }
};

exports.verifyEmail = async (req, res) => {
  try {
    // TODO: Implement verifyEmail logic
    res.status(501).json({ message: 'verifyEmail not implemented yet' });
  } catch (error) {
    res.status(500).json({ message: 'Error verifying email', error: error.message });
  }
};

================
File: src/middleware/auth.js
================
const auth = (req, res, next) => {
    console.log('Auth middleware');
    next();
};

module.exports = auth;

================
File: src/middleware/isAdmin.js
================
const isAdmin = (req, res, next) => {
    if (req.user && req.user.role === 'admin') {
      next();
    } else {
      res.status(403).json({ message: 'Access denied. Admin only.' });
    }
  };
  
  module.exports = isAdmin;

================
File: src/middleware/rateLimit.js
================
const rateLimit = {
  register: (req, res, next) => {
    console.log('Rate limit middleware for registration');
    next();
  },
  login: (req, res, next) => {
    console.log('Rate limit middleware for login');
    next();
  },
  forgotPassword: (req, res, next) => {
    console.log('Rate limit middleware for forgot password');
    next();
  },
  comment: (req, res, next) => {
    console.log('Rate limit middleware for comment');
    next();
  },
  createDeal: (req, res, next) => {
    console.log('Rate limit applied for deal creation');
    next();
  },
  vote: (req, res, next) => {
    console.log('Rate limit applied for voting');
    next();
  }
};

module.exports = rateLimit;

================
File: src/models/Comment.Model.js
================
const mongoose = require('mongoose');

const commentSchema = new mongoose.Schema({
  content: { type: String, required: true },
  user: { type: mongoose.Schema.Types.ObjectId, ref: 'User', required: true, index: true },
  deal: { type: mongoose.Schema.Types.ObjectId, ref: 'Deal', required: true, index: true },
  parentComment: { type: mongoose.Schema.Types.ObjectId, ref: 'Comment' },
  status: { type: String, enum: ['active', 'deleted'], default: 'active' }
}, { 
  timestamps: true,
  toJSON: { virtuals: true },
  toObject: { virtuals: true }
});

commentSchema.virtual('replies', {
  ref: 'Comment',
  localField: '_id',
  foreignField: 'parentComment'
});

module.exports = mongoose.model('Comment', commentSchema);

================
File: src/models/Deal.Model.js
================
const mongoose = require('mongoose');

const dealSchema = new mongoose.Schema({
  title: { type: String, required: true, index: 'text' },
  description: { type: String, index: 'text' },
  price: { type: Number, required: true },
  originalPrice: Number,
  currency: { type: String, default: 'USD' },
  url: { type: String, required: true },
  imageUrl: String,
  store: { type: String, index: true },
  category: { type: String, index: true },
  user: { type: mongoose.Schema.Types.ObjectId, ref: 'User', required: true, index: true },
  status: { type: String, enum: ['active', 'expired', 'deleted'], default: 'active', index: true },
  expiresAt: Date,
  tags: [{ type: String, index: true }],
  metadata: {
    source: String,
    affiliate: Boolean,
    affiliateCode: String
  },
  priceHistory: [{
    price: Number,
    date: { type: Date, default: Date.now }
  }],
  analytics: {
    views: { type: Number, default: 0 },
    clicks: { type: Number, default: 0 },
    conversions: { type: Number, default: 0 }
  },
  location: {
    country: String,
    city: String
  }
}, { 
  timestamps: true,
  toJSON: { virtuals: true },
  toObject: { virtuals: true }
});

dealSchema.virtual('voteCount', {
  ref: 'Vote',
  localField: '_id',
  foreignField: 'deal',
  count: true
});

dealSchema.virtual('commentCount', {
  ref: 'Comment',
  localField: '_id',
  foreignField: 'deal',
  count: true
});

dealSchema.index({ title: 'text', description: 'text', tags: 'text' });

module.exports = mongoose.model('Deal', dealSchema);

================
File: src/models/Follow.Model.js
================
const mongoose = require('mongoose');

const followSchema = new mongoose.Schema({
  follower: { type: mongoose.Schema.Types.ObjectId, ref: 'User', required: true },
  followed: { type: mongoose.Schema.Types.ObjectId, ref: 'User', required: true }
}, { 
  timestamps: true 
});

followSchema.index({ follower: 1, followed: 1 }, { unique: true });

module.exports = mongoose.model('Follow', followSchema);

================
File: src/models/User.Model.js
================
const mongoose = require('mongoose');
const bcrypt = require('bcryptjs');

const userSchema = new mongoose.Schema({
  username: { type: String, required: true, unique: true, index: true },
  email: { type: String, required: true, unique: true, index: true },
  password: { type: String, required: true },
  profilePicture: String,
  bio: String,
  role: { type: String, enum: ['user', 'admin'], default: 'user' },
  isVerified: { type: Boolean, default: false },
  verificationToken: String,
  resetPasswordToken: String,
  resetPasswordExpires: Date,
  lastLogin: Date,
  preferences: {
    notifications: {
      email: { type: Boolean, default: true },
      push: { type: Boolean, default: true }
    },
    privacy: {
      showEmail: { type: Boolean, default: false },
      showActivity: { type: Boolean, default: true }
    }
  },
  socialProfiles: {
    facebook: String,
    twitter: String,
    instagram: String
  },
  reputation: { type: Number, default: 0 },
  badges: [String],
  favoriteCategories: [String],
  favoriteStores: [String],
  location: {
    country: String,
    city: String
  }
}, { 
  timestamps: true,
  toJSON: { virtuals: true },
  toObject: { virtuals: true }
});

userSchema.virtual('followersCount', {
  ref: 'Follow',
  localField: '_id',
  foreignField: 'followed',
  count: true
});

userSchema.virtual('followingCount', {
  ref: 'Follow',
  localField: '_id',
  foreignField: 'follower',
  count: true
});

userSchema.virtual('dealsCount', {
  ref: 'Deal',
  localField: '_id',
  foreignField: 'user',
  count: true
});

userSchema.pre('save', async function(next) {
  if (!this.isModified('password')) return next();
  this.password = await bcrypt.hash(this.password, 10);
  next();
});

userSchema.methods.comparePassword = async function(candidatePassword) {
  return bcrypt.compare(candidatePassword, this.password);
};

module.exports = mongoose.model('User', userSchema);

================
File: src/models/Vote.Model.js
================
const mongoose = require('mongoose');

const voteSchema = new mongoose.Schema({
  user: { type: mongoose.Schema.Types.ObjectId, ref: 'User', required: true },
  deal: { type: mongoose.Schema.Types.ObjectId, ref: 'Deal', required: true },
  value: { type: Number, enum: [-1, 1], required: true }
}, { 
  timestamps: true 
});

voteSchema.index({ user: 1, deal: 1 }, { unique: true });

module.exports = mongoose.model('Vote', voteSchema);

================
File: src/routes/api/v1/Admin.Route.js
================
const express = require('express');
const router = express.Router();
const adminController = require('../../../controllers/adminController');
const auth = require('../../../middleware/auth');
const isAdmin = require('../../../middleware/isAdmin');

router.use(auth, isAdmin);

router.get('/users', adminController.getUsers);
router.put('/users/:id', adminController.updateUser);
router.delete('/users/:id', adminController.deleteUser);
router.get('/deals', adminController.getDeals);
router.put('/deals/:id', adminController.updateDeal);
router.delete('/deals/:id', adminController.deleteDeal);
router.get('/comments', adminController.getComments);
router.delete('/comments/:id', adminController.deleteComment);
router.get('/stats', adminController.getStats);

module.exports = router;

================
File: src/routes/api/v1/Comment.Route.js
================
const express = require('express');
const router = express.Router();
const commentController = require('../../../controllers/commentController');
const auth = require('../../../middleware/auth');
const rateLimit = require('../../../middleware/rateLimit');

// Check this line (line 9):
router.post('/', auth, rateLimit.createComment, commentController.createComment);

// Add other routes as needed
router.get('/:id', commentController.getComment);
router.put('/:id', auth, commentController.updateComment);
router.delete('/:id', auth, commentController.deleteComment);

module.exports = router;

================
File: src/routes/api/v1/Deal.Route.js
================
const express = require('express');
const router = express.Router();
const dealController = require('../../../controllers/dealController');
const auth = require('../../../middleware/auth');
const rateLimit = require('../../../middleware/rateLimit');

router.get('/', dealController.getDeals);
router.post('/', auth, rateLimit.createDeal, dealController.createDeal);
router.get('/:id', dealController.getDeal);
router.put('/:id', auth, dealController.updateDeal);
router.delete('/:id', auth, dealController.deleteDeal);
router.post('/:id/vote', auth, rateLimit.vote, dealController.voteDeal);
router.get('/:id/comments', dealController.getDealComments);
router.post('/:id/comments', auth, rateLimit.comment, dealController.addComment);

// These routes might not be implemented yet in your dealController
// Uncomment them when you've implemented the corresponding controller methods
// router.get('/search', dealController.searchDeals);
// router.get('/categories', dealController.getCategories);
// router.get('/stores', dealController.getStores);
// router.get('/trending', dealController.getTrendingDeals);
// router.get('/expiring-soon', dealController.getExpiringSoonDeals);

module.exports = router;

================
File: src/routes/api/v1/index.js
================
const express = require('express');
const router = express.Router();

router.use('/users', require('./User.Route'));
router.use('/deals', require('./Deal.Route'));
router.use('/comments', require('./Comment.Route'));
router.use('/admin', require('./Admin.Route'));

module.exports = router;

================
File: src/routes/api/v1/User.Route.js
================
const express = require('express');
const router = express.Router();
const path = require('path');
const userController = require(path.join(__dirname, '../../../controllers/userController'));
const auth = require('../../../middleware/auth');
const rateLimit = require('../../../middleware/rateLimit');

router.post('/register', rateLimit.register, userController.register);
router.post('/login', rateLimit.login, userController.login);
router.post('/logout', auth, userController.logout);
router.get('/me', auth, userController.getCurrentUser);
router.put('/me', auth, userController.updateCurrentUser);
router.get('/:id', userController.getUser);
router.get('/:id/deals', userController.getUserDeals);
router.get('/:id/followers', userController.getUserFollowers);
router.get('/:id/following', userController.getUserFollowing);
router.post('/:id/follow', auth, userController.followUser);
router.delete('/:id/follow', auth, userController.unfollowUser);
router.post('/forgot-password', rateLimit.forgotPassword, userController.forgotPassword);
router.post('/reset-password', userController.resetPassword);
router.post('/verify-email', userController.verifyEmail);

module.exports = router;

================
File: src/server.js
================
const mongoose = require('mongoose');
const app = require('./app');
const config = require('./config/config');

const PORT = config.port || 5000;

mongoose.connect(config.mongoUri)
  .then(() => {
    console.log('Connected to MongoDB');
    app.listen(PORT, () => {
      console.log(`Server is running on port ${PORT}`);
    });
  })
  .catch(err => console.error('Could not connect to MongoDB', err));

================
File: src/services/imageFetcherService.js
================
const axios = require('axios');
const cheerio = require('cheerio');

class ImageFetcherService {
	async fetchImageUrl(url) {
		console.log(`Fetching image URL for: ${url}`);
		
		if (url.includes('amazon')) {
			return this.fetchAmazonImageUrl(url);
		}
		
		try {
			const response = await axios.get(url);
			const $ = cheerio.load(response.data);
			
			let imageUrl = $('meta[property="og:image"]').attr('content');
			
			if (!imageUrl) {
				imageUrl = $('img').first().attr('src');
			}
			
			if (imageUrl && !imageUrl.startsWith('http')) {
				const baseUrl = new URL(url).origin;
				imageUrl = new URL(imageUrl, baseUrl).href;
			}

			console.log('Image URL found:', imageUrl);
			return imageUrl;
		} catch (error) {
			console.error('Error fetching image URL:', error.message);
			return null;
		}
	}

	fetchAmazonImageUrl(url) {
		const asin = this.extractAmazonASIN(url);
		if (asin) {
			const imageUrl = `https://images-na.ssl-images-amazon.com/images/P/${asin}.01._SCRM_.jpg`;
			console.log('Amazon image URL constructed:', imageUrl);
			return imageUrl;
		}
		console.error('Could not extract ASIN from Amazon URL');
		return null;
	}

	extractAmazonASIN(url) {
		const match = url.match(/\/dp\/(\w{10})/);
		return match ? match[1] : null;
	}
}

module.exports = ImageFetcherService;

================
File: src/testImageFetcher.js
================
const ImageFetcherService = require('./services/imageFetcherService');

async function testImageFetcher() {
  const testUrls = [
    'https://he.aliexpress.com/item/1005004763702938.html?spm=a2g0o.tm1000007309.2459882340.dundefined.54f76f3dyxh01R&pdp_ext_f=%7B%22ship_from%22:%22CN%22,%22sku_id%22:%2212000035244868987%22%7D&pdp_npi=4%40dis%21ILS%21%E2%82%AA%20114.34%21%E2%82%AA%2038.08%21%21%2129.97%219.98%21%402103085c17263319782914988ed468%2112000035244868987%21gdf%21IL%211657335144%21X&aecmd=true',
    'https://www.amazon.co.uk/Columbia-Classics-Collection-Blu-ray-Region/dp/B0DBH9NKMN/ref=sr_1_1?crid=YXGIJLRSHTSV&dib=eyJ2IjoiMSJ9.44NZBkQ3nrt6hHgj1dycKlkV8A9kw8aakrdJYBmvrGDjrwjmr2VkQidqe1p5P5uJAANn9p8QKQvL6DPOO9Y89HxCGwVFSDiINmtrNmrXSfsTkooFQn2Eq7Umhd8AScCG6-vJPgrmLiGRbWTF77xkXyKMlh6X5PDMNyReZNgGPCMDE3yf-L-9qfL4adQeBaAB.I72NBnAR_XQvXPS1F81_V25PF-7F-mUFAuW7EG9B4Rc&dib_tag=se&keywords=columbia+classics+4k+volume+5&qid=1726332076&sprefix=columbia%2Caps%2C158&sr=8-1',
    'https://www.ebay.com/itm/334109845538?_trksid=p4375194.c101800.m5481',
    'https://www.lastprice.co.il/p/100004176/%D7%9E%D7%99%D7%A7%D7%A1%D7%A8%2D%D7%9E%D7%A7%D7%A6%D7%95%D7%A2%D7%99%2D4.8%2D%D7%9C%D7%99%D7%98%D7%A8%2DKitchenAid/KitchenAid-Artisan%2D5KSM125EAC%2D%D7%A9%D7%A7%D7%93'
  ];

  const imageFetcher = new ImageFetcherService();

  for (const url of testUrls) {
    console.log(`\nTesting URL: ${url}`);
    try {
      const imageUrl = await imageFetcher.fetchImageUrl(url);
      console.log('Image URL:', imageUrl);
    } catch (error) {
      console.error('Error fetching image URL:', error.message);
    }
    console.log('-------------------');
  }
}

testImageFetcher();

================
File: src/utils/appError.js
================
class AppError extends Error {
    constructor(message, statusCode) {
      super(message);
      this.statusCode = statusCode;
      this.status = `${statusCode}`.startsWith('4') ? 'fail' : 'error';
      this.isOperational = true;

      Error.captureStackTrace(this, this.constructor);
    }
  }

  module.exports = AppError;

================
File: src/utils/catchAsync.js
================
module.exports = fn => {
    return (req, res, next) => {
      fn(req, res, next).catch(next);
    };
  };
