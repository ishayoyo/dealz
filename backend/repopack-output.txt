This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repopack on: 2024-09-30T06:15:32.306Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repopack's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

For more information about Repopack, visit: https://github.com/yamadashy/repopack

================================================================
Repository Structure
================================================================
.gitignore
package.json
src/app.js
src/config/config.js
src/controllers/adminController.js
src/controllers/commentController.js
src/controllers/dealController.js
src/controllers/notificationController.js
src/controllers/userController.js
src/middleware/auth.js
src/middleware/isAdmin.js
src/middleware/rateLimit.js
src/models/Activity.Model.js
src/models/Comment.Model.js
src/models/Deal.Model.js
src/models/Follow.Model.js
src/models/Notification.Model.js
src/models/User.Model.js
src/models/Vote.Model.js
src/routes/api/v1/Admin.Route.js
src/routes/api/v1/Comment.Route.js
src/routes/api/v1/Deal.Route.js
src/routes/api/v1/index.js
src/routes/api/v1/Notification.Route.js
src/routes/api/v1/User.Route.js
src/routes/testRoutes.js
src/server.js
src/services/imageFetcherService.js
src/services/NotificationService.js
src/testImageFetcher.js
src/utils/appError.js
src/utils/catchAsync.js

================================================================
Repository Files
================================================================

================
File: .gitignore
================
node_modules/
.env

================
File: package.json
================
{
  "name": "backend",
  "version": "1.0.0",
  "main": "src/server.js",
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1",
    "start": "node src/server.js",
    "dev": "nodemon src/server.js"
  },
  "keywords": [],
  "author": "",
  "license": "ISC",
  "dependencies": {
    "@azure/cognitiveservices-imagesearch": "^3.0.1",
    "@azure/ms-rest-azure-js": "^2.1.0",
    "axios": "^1.7.7",
    "bcryptjs": "^2.4.3",
    "cheerio": "^1.0.0",
    "compression": "^1.7.4",
    "cors": "^2.8.5",
    "dotenv": "^16.4.5",
    "express": "^4.21.0",
    "express-mongo-sanitize": "^2.2.0",
    "express-rate-limit": "^7.4.0",
    "fs-extra": "^11.2.0",
    "helmet": "^7.1.0",
    "hpp": "^0.2.3",
    "ioredis": "^5.4.1",
    "jsonwebtoken": "^9.0.2",
    "mongoose": "^8.6.2",
    "morgan": "^1.10.0",
    "multer": "^1.4.5-lts.1",
    "puppeteer": "^23.3.0",
    "puppeteer-extra": "^3.3.6",
    "puppeteer-extra-plugin-stealth": "^2.11.2",
    "sharp": "^0.33.5",
    "socket.io": "^4.8.0",
    "xss-clean": "^0.1.4"
  },
  "devDependencies": {
    "nodemon": "^3.1.4"
  },
  "description": ""
}

================
File: src/app.js
================
const express = require('express');
const cors = require('cors');
const path = require('path');
const routes = require('./routes/api/v1');

const app = express();

app.use(cors({
  origin: ["https://deals.ishay.me", "http://localhost:3000"],
  credentials: true
}));
app.use(express.json());
app.use(express.urlencoded({ extended: true }));

// Serve static files from the 'public' directory
app.use('/images', express.static(path.join(__dirname, '../public/images')));

app.use('/api/v1', routes);

// Global error handler
app.use((err, req, res, next) => {
  console.error('Error details:', err);
  res.status(err.statusCode || 500).json({
    status: 'error',
    message: err.message || 'Something went wrong on the server',
    stack: process.env.NODE_ENV === 'development' ? err.stack : undefined
  });
});

module.exports = app;

================
File: src/config/config.js
================
require('dotenv').config();

module.exports = {
  port: process.env.PORT || 5000,
  mongoUri: process.env.MONGO_URI,
  // Add other configuration variables as needed
};

================
File: src/controllers/adminController.js
================
const User = require('../models/User.Model');
const Deal = require('../models/Deal.Model');
const Comment = require('../models/Comment.Model');
const AppError = require('../utils/appError');
const catchAsync = require('../utils/catchAsync');

exports.getUsers = catchAsync(async (req, res, next) => {
  const users = await User.find().select('-password');

  res.status(200).json({
    status: 'success',
    results: users.length,
    data: { users }
  });
});

exports.updateUser = catchAsync(async (req, res, next) => {
  const user = await User.findByIdAndUpdate(req.params.id, req.body, {
    new: true,
    runValidators: true
  }).select('-password');

  if (!user) {
    return next(new AppError('No user found with that ID', 404));
  }

  res.status(200).json({
    status: 'success',
    data: { user }
  });
});

exports.deleteUser = catchAsync(async (req, res, next) => {
  const user = await User.findByIdAndDelete(req.params.id);

  if (!user) {
    return next(new AppError('No user found with that ID', 404));
  }

  res.status(204).json({
    status: 'success',
    data: null
  });
});

exports.getDeals = catchAsync(async (req, res, next) => {
  const deals = await Deal.find().populate('user', 'username');

  res.status(200).json({
    status: 'success',
    results: deals.length,
    data: { deals }
  });
});

exports.updateDeal = catchAsync(async (req, res, next) => {
  const deal = await Deal.findByIdAndUpdate(req.params.id, req.body, {
    new: true,
    runValidators: true
  });

  if (!deal) {
    return next(new AppError('No deal found with that ID', 404));
  }

  res.status(200).json({
    status: 'success',
    data: { deal }
  });
});

exports.deleteDeal = catchAsync(async (req, res, next) => {
  const deal = await Deal.findByIdAndDelete(req.params.id);

  if (!deal) {
    return next(new AppError('No deal found with that ID', 404));
  }

  res.status(204).json({
    status: 'success',
    data: null
  });
});

exports.getStats = catchAsync(async (req, res, next) => {
  const userCount = await User.countDocuments();
  const dealCount = await Deal.countDocuments();
  const commentCount = await Comment.countDocuments();

  res.status(200).json({
    status: 'success',
    data: {
      userCount,
      dealCount,
      commentCount
    }
  });
});

// More admin methods as needed

exports.getCollections = catchAsync(async (req, res, next) => {
  const users = await User.find().populate('collections');
  const collections = users.flatMap(user => user.collections);
  res.status(200).json({
    status: 'success',
    data: { collections }
  });
});

exports.updateCollection = catchAsync(async (req, res, next) => {
  const { name, description } = req.body;
  const user = await User.findOne({ 'collections._id': req.params.id });
  if (!user) {
    return next(new AppError('No collection found with that ID', 404));
  }
  const collection = user.collections.id(req.params.id);
  collection.name = name;
  collection.description = description;
  await user.save();
  res.status(200).json({
    status: 'success',
    data: { collection }
  });
});

exports.deleteCollection = catchAsync(async (req, res, next) => {
  const user = await User.findOne({ 'collections._id': req.params.id });
  if (!user) {
    return next(new AppError('No collection found with that ID', 404));
  }
  user.collections.id(req.params.id).remove();
  await user.save();
  res.status(204).json({
    status: 'success',
    data: null
  });
});

exports.getActivity = catchAsync(async (req, res, next) => {
  // Implement this based on your Activity model
  res.status(200).json({
    status: 'success',
    message: 'Not implemented yet'
  });
});

================
File: src/controllers/commentController.js
================
const Comment = require('../models/Comment.Model');
const Deal = require('../models/Deal.Model');
const AppError = require('../utils/appError');
const catchAsync = require('../utils/catchAsync');
const NotificationService = require('../services/NotificationService');
const User = require('../models/User.Model');

const parseMentions = (content) => {
  const mentionRegex = /@([\w.@]+)/g;
  return (content.match(mentionRegex) || []).map(mention => mention.slice(1));
};

exports.createComment = catchAsync(async (req, res, next) => {
  const { content } = req.body;
  const { dealId } = req.params;
  const userId = req.user.id;

  console.log('Creating comment:', { content, dealId, userId });

  const deal = await Deal.findById(dealId);
  if (!deal) {
    return next(new AppError('No deal found with that ID', 404));
  }

  const comment = new Comment({
    content,
    user: userId,
    deal: dealId
  });

  const newComment = await comment.save();
  console.log('New comment created:', newComment);

  // Update the deal with the new comment
  await Deal.findByIdAndUpdate(dealId, { $push: { comments: newComment._id } });

  const notificationService = new NotificationService(req.app.get('io'));

  // Create notification for deal owner
  if (deal.user.toString() !== userId) {
    console.log('Creating notification for deal owner');
    await notificationService.createNotification({
      recipient: deal.user,
      type: 'NEW_COMMENT',
      content: `${req.user.username} commented on your deal: ${deal.title}`,
      relatedUser: userId,
      relatedDeal: dealId,
      relatedComment: newComment._id
    });
  }

  // Handle @mentions
  console.log('Parsing mentions from:', content);
  const mentionedUsernames = parseMentions(content);
  console.log('Mentioned usernames:', mentionedUsernames);

  for (const username of mentionedUsernames) {
    console.log('Looking up user:', username);
    const mentionedUser = await User.findOne({ username });
    if (mentionedUser && mentionedUser._id.toString() !== userId) {
      console.log('Creating mention notification for:', mentionedUser.username);
      await notificationService.createNotification({
        recipient: mentionedUser._id,
        type: 'MENTION',
        content: `${req.user.username} mentioned you in a comment on a deal`,
        relatedUser: userId,
        relatedDeal: dealId,
        relatedComment: newComment._id
      });
    }
  }

  res.status(201).json({
    status: 'success',
    data: {
      comment: newComment
    }
  });
});

exports.getComment = catchAsync(async (req, res, next) => {
  const comment = await Comment.findById(req.params.id)
    .populate('user', 'username profilePicture')
    .populate('replies');
  
  if (!comment) {
    return next(new AppError('No comment found with that ID', 404));
  }

  res.status(200).json({
    status: 'success',
    data: { comment }
  });
});

exports.updateComment = catchAsync(async (req, res, next) => {
  const { content } = req.body;
  const comment = await Comment.findOneAndUpdate(
    { _id: req.params.id, user: req.user.id },
    { content },
    { new: true, runValidators: true }
  );

  if (!comment) {
    return next(new AppError('No comment found with that ID or you are not authorized', 404));
  }

  res.status(200).json({
    status: 'success',
    data: { comment }
  });
});

exports.deleteComment = catchAsync(async (req, res, next) => {
  const comment = await Comment.findOneAndUpdate(
    { _id: req.params.id, user: req.user.id },
    { status: 'deleted' },
    { new: true }
  );

  if (!comment) {
    return next(new AppError('No comment found with that ID or you are not authorized', 404));
  }

  res.status(204).json({
    status: 'success',
    data: null
  });
});


exports.getComments = catchAsync(async (req, res, next) => {
  const { dealId } = req.params;
  const comments = await Comment.find({ deal: dealId, status: 'active', parentComment: null })
    .populate('user', 'username profilePicture')
    .populate({
      path: 'replies',
      populate: { path: 'user', select: 'username profilePicture' }
    })
    .sort('-createdAt');

  console.log('Fetched comments:', JSON.stringify(comments, null, 2)); // More detailed logging

  res.status(200).json({
    status: 'success',
    results: comments.length,
    data: { comments }
  });
});

exports.createReply = catchAsync(async (req, res, next) => {
  const { content } = req.body;
  const { commentId } = req.params;
  const userId = req.user.id;

  const parentComment = await Comment.findById(commentId);
  if (!parentComment) {
    return next(new AppError('No parent comment found with that ID', 404));
  }

  const reply = await Comment.create({
    content,
    user: userId,
    deal: parentComment.deal,
    parentComment: commentId
  });

  const populatedReply = await Comment.findById(reply._id).populate('user', 'username profilePicture');

  // Create notification for parent comment owner
  const notificationService = new NotificationService(req.app.get('io'));
  if (parentComment.user.toString() !== userId) {
    await notificationService.createNotification({
      recipient: parentComment.user,
      type: 'reply',
      content: `${req.user.username} replied to your comment`,
      relatedUser: userId,
      relatedDeal: parentComment.deal,
      relatedComment: reply._id
    });
  }

  // Handle @mentions
  const mentionRegex = /@(\w+)/g;
  let match;
  while ((match = mentionRegex.exec(content)) !== null) {
    const username = match[1];
    const mentionedUser = await User.findOne({ username });
    if (mentionedUser && mentionedUser._id.toString() !== userId) {
      await notificationService.createNotification({
        recipient: mentionedUser._id,
        type: 'mention',
        content: `${req.user.username} mentioned you in a reply to a comment`,
        relatedUser: userId,
        relatedDeal: parentComment.deal,
        relatedComment: reply._id
      });
    }
  }

  res.status(201).json({
    status: 'success',
    data: { reply: populatedReply }
  });
});

================
File: src/controllers/dealController.js
================
// File: src/controllers/dealController.js

const Deal = require('../models/Deal.Model');
const User = require('../models/User.Model');
const Comment = require('../models/Comment.Model');
const Vote = require('../models/Vote.Model');
const Follow = require('../models/Follow.Model');
const AppError = require('../utils/appError');
const catchAsync = require('../utils/catchAsync');
const ImageFetcherService = require('../services/imageFetcherService');
const sharp = require('sharp');
const path = require('path');
const fs = require('fs').promises;
const NotificationService = require('../services/NotificationService');

exports.getDeals = catchAsync(async (req, res, next) => {
  const page = parseInt(req.query.page, 10) || 1;
  const limit = parseInt(req.query.limit, 10) || 10;
  const skip = (page - 1) * limit;

  const deals = await Deal.find({ status: 'active' })
    .sort('-createdAt')
    .skip(skip)
    .limit(limit)
    .populate('user', 'username profilePicture');

  const total = await Deal.countDocuments({ status: 'active' });

  res.status(200).json({
    status: 'success',
    results: deals.length,
    total,
    page,
    totalPages: Math.ceil(total / limit),
    data: { deals }
  });
});

exports.createDeal = catchAsync(async (req, res, next) => {
  const { title, description, price, imageUrl, link } = req.body;

  if (!imageUrl) {
    return next(new AppError('Image URL is required', 400));
  }

  if (!link) {
    return next(new AppError('Deal link is required', 400));
  }

  const deal = await Deal.create({
    title,
    description,
    price,
    imageUrl,
    url: link,
    user: req.user.id
  });

  // Automatically follow the deal
  await User.findByIdAndUpdate(req.user.id, { $addToSet: { followedDeals: deal._id } });
  deal.followCount = 1;
  await deal.save();

  // Get the user's followers
  const user = await User.findById(req.user.id);
  const followers = await User.find({ _id: { $in: user.followers } });

  // Create notifications for followers
  const notificationService = new NotificationService(req.app.get('io'));
  for (let follower of followers) {
    await notificationService.createNotification({
      recipient: follower._id,
      type: 'NEW_DEAL',
      content: `${user.username} posted a new deal: ${deal.title}`,
      relatedUser: user._id,
      relatedDeal: deal._id
    });
  }

  // Populate the user field
  await deal.populate('user', 'username profilePicture');

  // Emit socket event for new deal
  const io = req.app.get('io');
  io.emit('newDeal', { deal });

  res.status(201).json({
    status: 'success',
    data: { deal }
  });
});

exports.getDeal = catchAsync(async (req, res, next) => {
  const deal = await Deal.findById(req.params.id)
    .populate('user', 'username profilePicture')
    .populate({
      path: 'comments',
      populate: { path: 'user', select: 'username profilePicture' }
    });

  if (!deal) {
    return next(new AppError('No deal found with that ID', 404));
  }

  res.status(200).json({
    status: 'success',
    data: { deal }
  });
});

exports.updateDeal = catchAsync(async (req, res, next) => {
  const deal = await Deal.findById(req.params.id);

  if (!deal) {
    return next(new AppError('No deal found with that ID', 404));
  }

  if (deal.user.toString() !== req.user.id && req.user.role !== 'admin') {
    return next(new AppError('You do not have permission to perform this action', 403));
  }

  Object.assign(deal, req.body);
  await deal.save();

  res.status(200).json({
    status: 'success',
    data: { deal }
  });
});

exports.deleteDeal = catchAsync(async (req, res, next) => {
  const deal = await Deal.findById(req.params.id);

  if (!deal) {
    return next(new AppError('No deal found with that ID', 404));
  }

  if (deal.user.toString() !== req.user.id && req.user.role !== 'admin') {
    return next(new AppError('You do not have permission to perform this action', 403));
  }

  await deal.deleteOne();

  res.status(204).json({
    status: 'success',
    data: null
  });
});

const parseMentions = (content) => {
  const mentionRegex = /@(\w+)/g;
  return (content.match(mentionRegex) || []).map(mention => mention.slice(1));
};

exports.addComment = catchAsync(async (req, res, next) => {
  console.log('Adding comment:', req.body);
  const deal = await Deal.findById(req.params.id);
  if (!deal) {
    return next(new AppError('No deal found with that ID', 404));
  }

  const comment = await Comment.create({
    content: req.body.content,
    user: req.user.id,
    deal: deal.id
  });

  console.log('Comment created:', comment);

  // Handle mentions
  console.log('Parsing mentions from:', req.body.content);
  const mentionedUsernames = parseMentions(req.body.content);
  console.log('Mentioned usernames:', mentionedUsernames);

  try {
    for (const username of mentionedUsernames) {
      console.log('Looking up user:', username);
      const mentionedUser = await User.findOne({ username });
      console.log('Found user:', mentionedUser);
      if (mentionedUser) {
        console.log('Creating mention notification for:', mentionedUser.username);
        await req.app.get('notificationService').createMentionNotification(
          req.user.id,
          mentionedUser.id,
          deal.id,
          comment.id
        );
      }
    }
  } catch (error) {
    console.error('Error handling mentions:', error);
  }

  // Create notification for deal owner
  if (deal.user.toString() !== req.user.id) {
    console.log('Creating comment notification for deal owner');
    await req.app.get('notificationService').createCommentNotification(
      req.user.id,
      deal.user,
      deal.id
    );
  }

  res.status(201).json({
    status: 'success',
    data: { comment }
  });
});

exports.getDealComments = catchAsync(async (req, res, next) => {
  const deal = await Deal.findById(req.params.id);
  if (!deal) {
    return next(new AppError('No deal found with that ID', 404));
  }

  const comments = await Comment.find({ deal: deal._id })
    .populate('user', 'username profilePicture')
    .sort('-createdAt');

  res.status(200).json({
    status: 'success',
    data: { comments }
  });
});

exports.markAsBought = catchAsync(async (req, res, next) => {
  const deal = await Deal.findById(req.params.id);
  if (!deal) {
    return next(new AppError('No deal found with that ID', 404));
  }

  deal.boughtCount += 1;
  await deal.save();

  res.status(200).json({
    status: 'success',
    data: { boughtCount: deal.boughtCount }
  });
});

exports.searchDeals = catchAsync(async (req, res, next) => {
  const { query, category, store, minPrice, maxPrice, sortBy } = req.query;
  const page = parseInt(req.query.page, 10) || 1;
  const limit = parseInt(req.query.limit, 10) || 10;
  const skip = (page - 1) * limit;

  let filter = { status: 'active' };
  if (query) {
    filter.$or = [
      { title: { $regex: query, $options: 'i' } },
      { description: { $regex: query, $options: 'i' } },
      { 'user.username': { $regex: query, $options: 'i' } }
    ];
  }
  if (category) filter.category = category;
  if (store) filter.store = store;
  if (minPrice || maxPrice) {
    filter.price = {};
    if (minPrice) filter.price.$gte = parseFloat(minPrice);
    if (maxPrice) filter.price.$lte = parseFloat(maxPrice);
  }

  let sort = {};
  if (sortBy === 'price_asc') sort.price = 1;
  else if (sortBy === 'price_desc') sort.price = -1;
  else sort.createdAt = -1;

  const deals = await Deal.find(filter)
    .sort(sort)
    .skip(skip)
    .limit(limit)
    .populate('user', 'username profilePicture');

  const total = await Deal.countDocuments(filter);

  res.status(200).json({
    status: 'success',
    results: deals.length,
    total,
    page,
    totalPages: Math.ceil(total / limit),
    data: { deals }
  });
});

exports.getCategories = catchAsync(async (req, res, next) => {
  const categories = await Deal.distinct('category');
  res.status(200).json({
    status: 'success',
    data: { categories }
  });
});

exports.getStores = catchAsync(async (req, res, next) => {
  const stores = await Deal.distinct('store');
  res.status(200).json({
    status: 'success',
    data: { stores }
  });
});

exports.getTrendingDeals = catchAsync(async (req, res, next) => {
  const deals = await Deal.find({ status: 'active' })
    .sort('-upvotes -commentCount -createdAt')
    .limit(10)
    .populate('user', 'username profilePicture');

  res.status(200).json({
    status: 'success',
    data: { deals }
  });
});

exports.getExpiringSoonDeals = catchAsync(async (req, res, next) => {
  const now = new Date();
  const twentyFourHoursLater = new Date(now.getTime() + 24 * 60 * 60 * 1000);

  const deals = await Deal.find({
    status: 'active',
    expirationDate: { $gte: now, $lte: twentyFourHoursLater }
  })
    .sort('expirationDate')
    .limit(10)
    .populate('user', 'username profilePicture');

  res.status(200).json({
    status: 'success',
    data: { deals }
  });
});

exports.checkDealStatus = catchAsync(async (req, res, next) => {
  const deal = await Deal.findById(req.params.id);
  if (!deal) {
    return next(new AppError('No deal found with that ID', 404));
  }

  res.status(200).json({
    status: 'success',
    data: { status: deal.status }
  });
});

exports.followDeal = catchAsync(async (req, res, next) => {
  const deal = await Deal.findById(req.params.id);
  if (!deal) {
    return next(new AppError('No deal found with that ID', 404));
  }

  const user = await User.findById(req.user.id);
  if (!user.followedDeals.includes(deal._id)) {
    user.followedDeals.push(deal._id);
    await user.save();
    deal.followCount += 1;
    await deal.save();

    // Add this code to create a notification
    if (deal.user.toString() !== req.user.id) {
      const notificationService = new NotificationService(req.app.get('io'));
      await notificationService.createDealFollowNotification(req.user.id, deal.user, deal._id);
    }
  }

  res.status(200).json({
    status: 'success',
    message: 'Deal followed successfully',
    data: {
      isFollowing: true,
      followCount: deal.followCount
    }
  });
});

exports.unfollowDeal = catchAsync(async (req, res, next) => {
  const deal = await Deal.findById(req.params.id);
  if (!deal) {
    return next(new AppError('No deal found with that ID', 404));
  }

  const user = await User.findById(req.user.id);
  if (user.followedDeals.includes(deal._id)) {
    user.followedDeals = user.followedDeals.filter(id => id.toString() !== deal._id.toString());
    await user.save();
    deal.followCount = Math.max(0, deal.followCount - 1);
    await deal.save();
  }

  res.status(200).json({
    status: 'success',
    message: 'Deal unfollowed successfully',
    data: {
      isFollowing: false,
      followCount: deal.followCount
    }
  });
});

exports.fetchImage = catchAsync(async (req, res, next) => {
  const { url } = req.body;
    
  if (!url) {
    return next(new AppError('URL is required', 400));
  }

  const imageFetcher = new ImageFetcherService();
  const imageUrl = await imageFetcher.fetchAndSaveImage(url);

  if (!imageUrl) {
    return next(new AppError('Unable to fetch image for the provided URL', 404));
  }

  res.status(200).json({
    status: 'success',
    data: { imageUrl }
  });
});

exports.uploadImage = catchAsync(async (req, res, next) => {
  if (!req.file) {
    return next(new AppError('No file uploaded', 400));
  }

  const filename = `deal-${req.user.id}-${Date.now()}.jpeg`;
  const filepath = path.join(__dirname, '..', '..', 'public', 'images', 'deals', filename);

  await sharp(req.file.buffer)
    .resize(800, 600)
    .toFormat('jpeg')
    .jpeg({ quality: 90 })
    .toFile(filepath);

  const imageUrl = `/images/deals/${filename}`;

  res.status(200).json({
    status: 'success',
    data: { imageUrl }
  });
});

exports.getFollowedDeals = catchAsync(async (req, res, next) => {
  const user = await User.findById(req.user.id).populate('followedDeals');
  res.status(200).json({
    status: 'success',
    data: { followedDeals: user.followedDeals }
  });
});

exports.getMentionableUsers = catchAsync(async (req, res, next) => {
  const deal = await Deal.findById(req.params.id);
  if (!deal) {
    return next(new AppError('No deal found with that ID', 404));
  }

  // Get users who commented on the deal
  const commenters = await Comment.find({ deal: deal._id }).distinct('user');

  // Get users who are following the deal
  const followers = await User.find({ followedDeals: deal._id });

  // Combine all user IDs, including the deal creator
  const userIds = new Set([
    ...commenters.map(id => id.toString()),
    ...followers.map(user => user._id.toString()),
    deal.user.toString()
  ]);

  // Fetch user details
  const users = await User.find({ _id: { $in: Array.from(userIds) } })
    .select('username profilePicture');

  res.status(200).json({
    status: 'success',
    data: { users }
  });
});

module.exports = exports;

================
File: src/controllers/notificationController.js
================
const Notification = require('../models/Notification.Model');
const catchAsync = require('../utils/catchAsync');
const AppError = require('../utils/appError');

exports.getNotifications = catchAsync(async (req, res, next) => {
  console.log('Fetching notifications for user:', req.user.id);
  
  const notifications = await Notification.find({ recipient: req.user.id })
    .sort('-createdAt')
    .limit(20);
  
  console.log('Fetched notifications:', notifications);

  res.status(200).json({
    status: 'success',
    data: { notifications }
  });
});

exports.markAsRead = catchAsync(async (req, res, next) => {
  const notification = await Notification.findOneAndUpdate(
    { _id: req.params.id, recipient: req.user.id },
    { read: true },  // Changed from isRead to read
    { new: true }
  );

  if (!notification) {
    return next(new AppError('No notification found with that ID', 404));
  }

  res.status(200).json({
    status: 'success',
    data: { notification }
  });
});

exports.markAllAsRead = catchAsync(async (req, res, next) => {
  console.log('Marking all notifications as read for user:', req.user.id);
  
  const updateResult = await Notification.updateMany(
    { recipient: req.user.id, read: false },
    { read: true }
  );
  
  console.log('Update result:', updateResult);
  
  const updatedNotifications = await Notification.find({ recipient: req.user.id })
    .sort('-createdAt')
    .limit(20);

  console.log('Updated notifications:', updatedNotifications);

  res.status(200).json({
    status: 'success',
    message: 'All notifications marked as read',
    data: { notifications: updatedNotifications }
  });
});

exports.deleteNotification = catchAsync(async (req, res, next) => {
  const notification = await Notification.findOneAndDelete({ _id: req.params.id, recipient: req.user.id });

  if (!notification) {
    return next(new AppError('No notification found with that ID', 404));
  }

  res.status(204).json({
    status: 'success',
    data: null
  });
});

================
File: src/controllers/userController.js
================
const User = require('../models/User.Model');
const Deal = require('../models/Deal.Model');
const Follow = require('../models/Follow.Model');
const jwt = require('jsonwebtoken');
const bcrypt = require('bcryptjs');
const catchAsync = require('../utils/catchAsync');
const AppError = require('../utils/appError');
const multer = require('multer');
const sharp = require('sharp');
const path = require('path');
const NotificationService = require('../services/NotificationService');

const signToken = id => {
  return jwt.sign({ id }, process.env.JWT_SECRET, {
    expiresIn: '1h'
  });
};

exports.register = catchAsync(async (req, res, next) => {
  const { username, email, password } = req.body;

  console.log('Registration attempt:', { username, email, password: password ? '[REDACTED]' : undefined });

  if (!username || !email || !password) {
    console.log('Missing required fields');
    return next(new AppError('Please provide username, email and password', 400));
  }

  try {
    // Check if user already exists
    const existingUser = await User.findOne({ $or: [{ email }, { username }] });
    if (existingUser) {
      console.log('User already exists:', { email, username });
      return next(new AppError('User with this email or username already exists', 400));
    }

    // Create new user
    const newUser = await User.create({
      username,
      email,
      password
    });

    console.log('New user created:', newUser._id);

    // Generate JWT
    const token = signToken(newUser._id);

    // Remove password from output
    newUser.password = undefined;

    res.status(201).json({
      status: 'success',
      token,
      data: { user: newUser }
    });
  } catch (error) {
    console.error('Registration error:', error);
    return next(new AppError('Error during registration', 500));
  }
});

exports.login = catchAsync(async (req, res, next) => {
  const { email, password } = req.body;

  console.log('Login attempt:', { email, password: password ? '[REDACTED]' : undefined });

  if (!email || !password) {
    console.log('Missing email or password');
    return next(new AppError('Please provide email and password', 400));
  }

  try {
    const user = await User.findOne({ email }).select('+password');
    
    if (!user || !(await user.comparePassword(password))) {
      console.log('Incorrect email or password');
      return next(new AppError('Incorrect email or password', 401));
    }

    console.log('Login successful:', user._id);

    const token = signToken(user._id);
    
    // Remove password from output
    user.password = undefined;

    res.status(200).json({ 
      status: 'success', 
      token,
      data: { user }
    });
  } catch (error) {
    console.error('Login error:', error);
    return next(new AppError('Error during login', 500));
  }
});

exports.logout = catchAsync(async (req, res) => {
  // If you're keeping track of valid tokens, invalidate this token
  // For example, if you're using a blacklist of invalid tokens:
  // await BlacklistedToken.create({ token: req.token });

  res.status(200).json({ status: 'success', message: 'Logged out successfully' });
});

exports.getCurrentUser = catchAsync(async (req, res, next) => {
  const user = await User.findById(req.user.id);
  res.status(200).json({ status: 'success', data: { user } });
});

exports.updateCurrentUser = catchAsync(async (req, res, next) => {
  const updatedUser = await User.findByIdAndUpdate(req.user.id, req.body, {
    new: true,
    runValidators: true
  });
  res.status(200).json({ status: 'success', data: { user: updatedUser } });
});

exports.getUser = catchAsync(async (req, res, next) => {
  const user = await User.findById(req.params.id);
  if (!user) {
    return next(new AppError('No user found with that ID', 404));
  }
  res.status(200).json({ status: 'success', data: { user } });
});

exports.getUserDeals = catchAsync(async (req, res, next) => {
  const deals = await Deal.find({ user: req.params.id });
  res.status(200).json({ status: 'success', data: { deals } });
});

exports.getUserFollowers = catchAsync(async (req, res, next) => {
  const followers = await Follow.find({ followed: req.params.id }).populate('follower');
  res.status(200).json({ status: 'success', data: { followers } });
});

exports.getUserFollowing = catchAsync(async (req, res, next) => {
  const following = await Follow.find({ follower: req.params.id }).populate('followed');
  res.status(200).json({ status: 'success', data: { following } });
});

exports.followUser = catchAsync(async (req, res, next) => {
  const userToFollow = await User.findById(req.params.id);
  if (!userToFollow) {
    return next(new AppError('No user found with that ID', 404));
  }

  // Prevent users from following themselves
  if (userToFollow._id.toString() === req.user.id) {
    return next(new AppError('You cannot follow yourself', 400));
  }

  const currentUser = await User.findById(req.user.id);

  // Check if already following
  if (currentUser.following.includes(userToFollow._id)) {
    return next(new AppError('You are already following this user', 400));
  }

  // Create new follow relationship
  await Follow.create({ follower: currentUser._id, followed: userToFollow._id });

  // Update the current user's following array
  currentUser.following.push(userToFollow._id);
  await currentUser.save();

  // Update the followed user's followers array
  userToFollow.followers.push(currentUser._id);
  await userToFollow.save();

  // Create notification for new follower
  const notificationService = new NotificationService(req.app.get('io'));
  await notificationService.createFollowNotification(currentUser._id, userToFollow._id);

  res.status(200).json({
    status: 'success',
    message: 'User followed successfully'
  });
});

exports.unfollowUser = catchAsync(async (req, res, next) => {
  const userToUnfollow = await User.findById(req.params.id);
  if (!userToUnfollow) {
    return next(new AppError('User not found', 404));
  }

  const existingFollow = await Follow.findOneAndDelete({ 
    follower: req.user._id, 
    followed: userToUnfollow._id 
  });

  if (!existingFollow) {
    return next(new AppError('You are not following this user', 400));
  }

  // Update the current user's following array
  await User.findByIdAndUpdate(req.user._id, {
    $pull: { following: userToUnfollow._id }
  });

  // Update the unfollowed user's followers array
  await User.findByIdAndUpdate(userToUnfollow._id, {
    $pull: { followers: req.user._id }
  });

  res.status(200).json({
    status: 'success',
    message: 'User unfollowed successfully'
  });
});

exports.forgotPassword = catchAsync(async (req, res, next) => {
  // Implement password reset logic here
  res.status(200).json({ status: 'success', message: 'Password reset email sent' });
});

exports.verifyEmail = catchAsync(async (req, res, next) => {
  // Implement email verification logic here
  res.status(200).json({ status: 'success', message: 'Email verified successfully' });
});

exports.validateToken = catchAsync(async (req, res, next) => {
  // The user ID should be available in req.user.id, set by the auth middleware
  const user = await User.findById(req.user.id).select('-password');
  
  if (!user) {
    return next(new AppError('User not found', 404));
  }
  
  res.status(200).json({
    status: 'success',
    data: {
      user: {
        id: user._id,
        username: user.username,
        email: user.email,
        // You can add more fields here as needed
      }
    }
  });
});

exports.getCurrentUserFollowing = catchAsync(async (req, res, next) => {
  console.log('getCurrentUserFollowing called');
  console.log('User ID:', req.user._id);
  try {
    const user = await User.findById(req.user._id).populate('following', 'username profilePicture');
    
    console.log('Following users found:', user.following.length);
    console.log('Following data:', user.following);
    
    res.status(200).json({
      status: 'success',
      data: { following: user.following }
    });
  } catch (error) {
    console.error('Error in getCurrentUserFollowing:', error);
    next(error);
  }
});

exports.createCollection = catchAsync(async (req, res, next) => {
  const { name, description } = req.body;
  const user = await User.findById(req.user.id);
  const newCollection = { name, description, deals: [] };
  user.collections.push(newCollection);
  await user.save();
  res.status(201).json({
    status: 'success',
    data: { collection: newCollection }
  });
});

exports.updateCollection = catchAsync(async (req, res, next) => {
  const { name, description } = req.body;
  const user = await User.findById(req.user.id);
  const collection = user.collections.id(req.params.id);
  if (!collection) {
    return next(new AppError('No collection found with that ID', 404));
  }
  collection.name = name;
  collection.description = description;
  await user.save();
  res.status(200).json({
    status: 'success',
    data: { collection }
  });
});

exports.deleteCollection = catchAsync(async (req, res, next) => {
  const user = await User.findById(req.user.id);
  user.collections.id(req.params.id).remove();
  await user.save();
  res.status(204).json({
    status: 'success',
    data: null
  });
});

exports.getCurrentUserActivity = catchAsync(async (req, res, next) => {
  // Implement this based on your Activity model
  res.status(200).json({
    status: 'success',
    message: 'Not implemented yet'
  });
});

exports.getUserActivity = catchAsync(async (req, res, next) => {
  // Implement this based on your Activity model
  res.status(200).json({
    status: 'success',
    message: 'Not implemented yet'
  });
});

exports.uploadProfilePicture = catchAsync(async (req, res, next) => {
  if (!req.file) {
    return next(new AppError('No file uploaded', 400));
  }

  const filename = `user-${req.user.id}-${Date.now()}.jpeg`;
  const filepath = path.join(__dirname, '..', '..', 'public', 'images', 'users', filename);

  await sharp(req.file.buffer)
    .resize(200, 200)
    .toFormat('jpeg')
    .jpeg({ quality: 90 })
    .toFile(filepath);

  const user = await User.findByIdAndUpdate(
    req.user.id,
    { profilePicture: `/images/users/${filename}` },
    { new: true, runValidators: true }
  );

  if (!user) {
    return next(new AppError('No user found with that ID', 404));
  }

  res.status(200).json({
    status: 'success',
    data: {
      user: {
        id: user._id,
        username: user.username,
        email: user.email,
        profilePicture: user.profilePicture
      }
    }
  });
});

exports.checkUserStatus = catchAsync(async (req, res, next) => {
  const targetUserId = req.params.id;
  const currentUserId = req.user.id;

  const currentUser = await User.findById(currentUserId);
  
  if (!currentUser) {
    return next(new AppError('Current user not found', 404));
  }

  const isFollowing = currentUser.following.includes(targetUserId);

  res.status(200).json({
    status: 'success',
    data: {
      isFollowing
    }
  });
});

exports.getCurrentUserFollowers = catchAsync(async (req, res, next) => {
  console.log('User ID:', req.user._id);
  try {
    const followers = await Follow.find({ followed: req.user._id })
      .populate('follower', 'username profilePicture');
    
    res.status(200).json({
      status: 'success',
      data: { followers: followers.map(f => f.follower) }
    });
  } catch (error) {
    console.error('Error in getCurrentUserFollowers:', error);
    next(error);
  }
});

exports.getCurrentUserDeals = catchAsync(async (req, res, next) => {
  console.log('User ID:', req.user._id);
  try {
    const deals = await Deal.find({ user: req.user._id }).sort('-createdAt');
    res.status(200).json({
      status: 'success',
      data: { deals }
    });
  } catch (error) {
    console.error('Error in getCurrentUserDeals:', error);
    next(error);
  }
});

exports.changePassword = catchAsync(async (req, res, next) => {
  console.log('Change password function called');
  const { currentPassword, newPassword, confirmPassword } = req.body;

  // Check if new password and confirm password match
  if (newPassword !== confirmPassword) {
    return next(new AppError('New password and confirm password do not match', 400));
  }

  // Get user from database
  const user = await User.findById(req.user.id).select('+password');

  // Check if current password is correct
  if (!(await user.comparePassword(currentPassword))) {
    return next(new AppError('Your current password is incorrect', 401));
  }

  // Update password
  user.password = newPassword;
  await user.save();

  // Send response
  res.status(200).json({
    status: 'success',
    message: 'Password updated successfully'
  });
});

exports.getCurrentUserCollections = catchAsync(async (req, res, next) => {
  const user = await User.findById(req.user.id).populate('collections');
  if (!user) {
    return next(new AppError('User not found', 404));
  }
  res.status(200).json({
    status: 'success',
    data: { collections: user.collections }
  });
});

exports.getCurrentUserFollowedDeals = catchAsync(async (req, res, next) => {
  console.log('getCurrentUserFollowedDeals called');
  console.log('User  called');
  console.log('User ID:', req.user._id);
  try {
    const user = await User.findById(req.user._id).populate({
      path: 'followedDeals',
      select: 'title description price imageUrl store category createdAt',
      populate: {
        path: 'user',
        select: 'username profilePicture'
      }
    });
    
    if (!user) {
      return next(new AppError('User not found', 404));
    }

    console.log('User found:', user);

    const safeFollowedDeals = user.followedDeals.map(deal => {
      try {
        // Only include specific fields to avoid problematic virtuals
        return {
          _id: deal._id,
          title: deal.title,
          description: deal.description,
          price: deal.price,
          imageUrl: deal.imageUrl,
          store: deal.store,
          category: deal.category,
          createdAt: deal.createdAt,
          user: deal.user ? {
            _id: deal.user._id,
            username: deal.user.username,
            profilePicture: deal.user.profilePicture
          } : null
        };
      } catch (error) {
        console.error('Error processing deal:', error);
        return null;
      }
    }).filter(deal => deal !== null);

    console.log('Safe followed deals:', safeFollowedDeals);

    res.status(200).json({
      status: 'success',
      data: { followedDeals: safeFollowedDeals }
    });
  } catch (error) {
    console.error('Error in getCurrentUserFollowedDeals:', error);
    next(error);
  }
});

exports.getUnreadNotifications = catchAsync(async (req, res, next) => {
  try {
    const notificationService = new NotificationService(req.app.get('io'));
    console.log('Fetching unread notifications for user:', req.user.id);
    const notifications = await notificationService.getUnreadNotifications(req.user.id);
    console.log('Fetched notifications:', notifications);

    res.status(200).json({
      status: 'success',
      data: { notifications }
    });
  } catch (error) {
    console.error('Error in getUnreadNotifications:', error);
    next(new AppError('Error fetching notifications', 500));
  }
});

exports.markNotificationAsRead = catchAsync(async (req, res, next) => {
  const notificationService = new NotificationService(req.app.get('io'));
  const notification = await notificationService.markAsRead(req.params.id);

  if (!notification) {
    return next(new AppError('No notification found with that ID', 404));
  }

  res.status(200).json({
    status: 'success',
    data: { notification }
  });
});

module.exports = exports;

================
File: src/middleware/auth.js
================
const jwt = require('jsonwebtoken');
const User = require('../models/User.Model');
const AppError = require('../utils/appError');
const catchAsync = require('../utils/catchAsync');

const auth = catchAsync(async (req, res, next) => {
  let token;

  if (req.headers.authorization && req.headers.authorization.startsWith('Bearer')) {
    token = req.headers.authorization.split(' ')[1];
  }

  if (!token) {
    return next(new AppError('You are not logged in! Please log in to get access.', 401));
  }

  try {
    const decoded = jwt.verify(token, process.env.JWT_SECRET);
    console.log('Decoded token:', decoded);

    const currentUser = await User.findById(decoded.id);
    if (!currentUser) {
      return next(new AppError('The user belonging to this token no longer exists.', 401));
    }

    console.log('Current user:', currentUser);
    req.user = currentUser;
    next();
  } catch (error) {
    console.error('Error in auth middleware:', error);
    return next(new AppError('Invalid token. Please log in again.', 401));
  }
});

module.exports = auth;

================
File: src/middleware/isAdmin.js
================
const isAdmin = (req, res, next) => {
    if (req.user && req.user.role === 'admin') {
      next();
    } else {
      res.status(403).json({ message: 'Access denied. Admin only.' });
    }
  };
  
  module.exports = isAdmin;

================
File: src/middleware/rateLimit.js
================
const rateLimit = {
  register: (req, res, next) => {
    console.log('Rate limit middleware for registration');
    next();
  },
  login: (req, res, next) => {
    console.log('Rate limit middleware for login');
    next();
  },
  forgotPassword: (req, res, next) => {
    console.log('Rate limit middleware for forgot password');
    next();
  },
  comment: (req, res, next) => {
    console.log('Rate limit middleware for comment');
    next();
  },
  createDeal: (req, res, next) => {
    console.log('Rate limit applied for deal creation');
    next();
  },
  vote: (req, res, next) => {
    console.log('Rate limit applied for voting');
    next();
  }
};

module.exports = rateLimit;

================
File: src/models/Activity.Model.js
================
const activitySchema = new mongoose.Schema({
    user: { type: mongoose.Schema.Types.ObjectId, ref: 'User', required: true, index: true },
    actionType: { type: String, enum: ['post_deal', 'comment', 'follow', 'vote', 'save_deal'], required: true },
    deal: { type: mongoose.Schema.Types.ObjectId, ref: 'Deal' },
    comment: { type: mongoose.Schema.Types.ObjectId, ref: 'Comment' },
    targetUser: { type: mongoose.Schema.Types.ObjectId, ref: 'User' },
    createdAt: { type: Date, default: Date.now, index: true }
  });
  
  activitySchema.index({ user: 1, createdAt: -1 });

================
File: src/models/Comment.Model.js
================
const mongoose = require('mongoose');

const commentSchema = new mongoose.Schema({
  content: { type: String, required: true },
  user: { type: mongoose.Schema.Types.ObjectId, ref: 'User', required: true, index: true },
  deal: { type: mongoose.Schema.Types.ObjectId, ref: 'Deal', required: true, index: true },
  parentComment: { type: mongoose.Schema.Types.ObjectId, ref: 'Comment' },
  status: { type: String, enum: ['active', 'deleted'], default: 'active' },
  voteScore: { type: Number, default: 0 },
  votes: [{
    user: { type: mongoose.Schema.Types.ObjectId, ref: 'User' },
    value: { type: Number, enum: [-1, 1] }
  }]
}, { 
  timestamps: true,
  toJSON: { 
    virtuals: true,
    transform: function(doc, ret) {
      ret.id = ret._id;
      delete ret._id;
      ret.createdAt = ret.createdAt.toISOString();
      ret.updatedAt = ret.updatedAt.toISOString();
      return ret;
    }
  },
  toObject: { virtuals: true }
});

commentSchema.virtual('replies', {
  ref: 'Comment',
  localField: '_id',
  foreignField: 'parentComment'
});

commentSchema.virtual('voteCount').get(function() {
  return this.votes.length;
});

module.exports = mongoose.model('Comment', commentSchema);

================
File: src/models/Deal.Model.js
================
const mongoose = require('mongoose');

const dealSchema = new mongoose.Schema({
  title: { type: String, required: true, index: 'text' },
  description: { type: String, index: 'text' },
  price: { type: Number, required: true },
  originalPrice: Number,
  currency: { type: String, default: 'USD' },
  url: { type: String, required: true },
  imageUrl: { type: String, required: true },
  userUploadedImage: { type: Boolean, default: false },
  store: { type: String, index: true },
  category: { type: String, index: true },
  user: { type: mongoose.Schema.Types.ObjectId, ref: 'User', required: true, index: true },
  status: { type: String, enum: ['active', 'expired', 'deleted'], default: 'active', index: true },
  expiresAt: Date,
  tags: [{ type: String, index: true }],
  metadata: {
    source: String,
    affiliate: Boolean,
    affiliateCode: String
  },
  priceHistory: [{
    price: Number,
    date: { type: Date, default: Date.now }
  }],
  analytics: {
    views: { type: Number, default: 0 },
    clicks: { type: Number, default: 0 },
    conversions: { type: Number, default: 0 },
    saves: { type: Number, default: 0 }
  },
  location: {
    country: String,
    city: String
  },
  comments: [{ type: mongoose.Schema.Types.ObjectId, ref: 'Comment' }],
  saveCount: { type: Number, default: 0 },
  collections: [{ type: mongoose.Schema.Types.ObjectId, ref: 'Collection' }],
  priceRange: { type: String, index: true },
  followCount: { type: Number, default: 0 },
  boughtCount: { type: Number, default: 0 },
  followers: [{ type: mongoose.Schema.Types.ObjectId, ref: 'User' }],
  buyers: [{ type: mongoose.Schema.Types.ObjectId, ref: 'User' }],
});

// Add this before any virtual definitions
dealSchema.set('toObject', { getters: true });
dealSchema.set('toJSON', { getters: true });


dealSchema.index({ title: 'text', description: 'text', tags: 'text' });

dealSchema.index({ createdAt: -1, voteCount: -1, saveCount: -1 });

dealSchema.index({ followCount: -1, boughtCount: -1 });

const Deal = mongoose.model('Deal', dealSchema);
module.exports = Deal;

================
File: src/models/Follow.Model.js
================
const mongoose = require('mongoose');

const followSchema = new mongoose.Schema({
  follower: { type: mongoose.Schema.Types.ObjectId, ref: 'User', required: true },
  followed: { type: mongoose.Schema.Types.ObjectId, ref: 'User', required: true }
}, { 
  timestamps: true 
});

followSchema.index({ follower: 1, followed: 1 }, { unique: true });

module.exports = mongoose.model('Follow', followSchema);

================
File: src/models/Notification.Model.js
================
const mongoose = require('mongoose');

const notificationSchema = new mongoose.Schema({
  recipient: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'User',
    required: true
  },
  type: {
    type: String,
    enum: ['NEW_DEAL', 'NEW_COMMENT', 'DEAL_FOLLOW', 'USER_FOLLOW', 'SYSTEM', 'FOLLOW', 'MENTION'],
    required: true
  },
  content: {
    type: String,
    required: true
  },
  read: {
    type: Boolean,
    default: false
  },
  relatedUser: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'User'
  },
  relatedDeal: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'Deal'
  },
  relatedComment: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'Comment'
  },
  createdAt: {
    type: Date,
    default: Date.now
  }
});

module.exports = mongoose.model('Notification', notificationSchema);

================
File: src/models/User.Model.js
================
const mongoose = require('mongoose');
const bcrypt = require('bcryptjs');

const userSchema = new mongoose.Schema({
  username: {
    type: String,
    required: [true, 'Please provide a username'],
    unique: true,
    trim: true,
  },
  email: {
    type: String,
    required: [true, 'Please provide an email'],
    unique: true,
    lowercase: true,
    trim: true,
  },
  password: {
    type: String,
    required: [true, 'Please provide a password'],
    minlength: 8,
    select: false,
  },
  profilePicture: String,
  bio: String,
  role: { type: String, enum: ['user', 'admin'], default: 'user' },
  isVerified: { type: Boolean, default: false },
  verificationToken: String,
  resetPasswordToken: String,
  resetPasswordExpires: Date,
  lastLogin: Date,
  preferences: {
    notifications: {
      email: { type: Boolean, default: true },
      push: { type: Boolean, default: true }
    },
    privacy: {
      showEmail: { type: Boolean, default: false },
      showActivity: { type: Boolean, default: true }
    }
  },
  socialProfiles: {
    facebook: String,
    twitter: String,
    instagram: String
  },
  reputation: { type: Number, default: 0 },
  badges: [String],
  favoriteCategories: [String],
  favoriteStores: [String],
  location: {
    country: String,
    city: String
  },
  boughtDeals: [{ type: mongoose.Schema.Types.ObjectId, ref: 'Deal' }],
  followedDeals: [{
    type: mongoose.Schema.ObjectId,
    ref: 'Deal'
  }],
  savedDeals: [{ type: mongoose.Schema.Types.ObjectId, ref: 'Deal' }],
  postedDeals: [{ type: mongoose.Schema.Types.ObjectId, ref: 'Deal' }],
  collections: [{ type: mongoose.Schema.Types.ObjectId, ref: 'Collection' }],
  favoritePriceRanges: [String],
  following: [{ type: mongoose.Schema.Types.ObjectId, ref: 'User' }],
  followers: [{ type: mongoose.Schema.ObjectId, ref: 'User' }],
}, { 
  timestamps: true,
  toJSON: { virtuals: true },
  toObject: { virtuals: true }
});

// Add this index for efficient user search
userSchema.index({ username: 'text', email: 'text' });

userSchema.virtual('followersCount', {
  ref: 'Follow',
  localField: '_id',
  foreignField: 'followed',
  count: true
});

userSchema.virtual('followingCount', {
  ref: 'Follow',
  localField: '_id',
  foreignField: 'follower',
  count: true
});

userSchema.virtual('dealsCount', {
  ref: 'Deal',
  localField: '_id',
  foreignField: 'user',
  count: true
});

userSchema.pre('save', async function(next) {
  if (!this.isModified('password')) return next();
  this.password = await bcrypt.hash(this.password, 12);
  next();
});

userSchema.methods.comparePassword = async function(candidatePassword) {
  return await bcrypt.compare(candidatePassword, this.password);
};

const User = mongoose.model('User', userSchema);

module.exports = User;

================
File: src/models/Vote.Model.js
================
const mongoose = require('mongoose');

const voteSchema = new mongoose.Schema({
  user: { type: mongoose.Schema.Types.ObjectId, ref: 'User', required: true },
  targetType: { type: String, enum: ['Deal', 'Comment'], required: true },
  targetId: { type: mongoose.Schema.Types.ObjectId, refPath: 'targetType', required: true },
  value: { type: Number, enum: [-1, 1], required: true }
}, { 
  timestamps: true 
});

voteSchema.index({ user: 1, targetType: 1, targetId: 1 }, { unique: true });

module.exports = mongoose.model('Vote', voteSchema);

================
File: src/routes/api/v1/Admin.Route.js
================
const express = require('express');
const router = express.Router();
const adminController = require('../../../controllers/adminController');
const auth = require('../../../middleware/auth');
const isAdmin = require('../../../middleware/isAdmin');

router.use(auth, isAdmin);

router.get('/users', adminController.getUsers);
router.put('/users/:id', adminController.updateUser);
router.delete('/users/:id', adminController.deleteUser);
router.get('/deals', adminController.getDeals);
router.put('/deals/:id', adminController.updateDeal);
router.delete('/deals/:id', adminController.deleteDeal);
router.get('/stats', adminController.getStats);

// Add these new routes
router.get('/collections', adminController.getCollections);
router.put('/collections/:id', adminController.updateCollection);
router.delete('/collections/:id', adminController.deleteCollection);

router.get('/activity', adminController.getActivity);

module.exports = router;

================
File: src/routes/api/v1/Comment.Route.js
================
const express = require('express');
const router = express.Router();
const commentController = require('../../../controllers/commentController');
const auth = require('../../../middleware/auth');

router.post('/:dealId/comments', auth, commentController.createComment);
router.get('/:id', commentController.getComment);
router.put('/:id', auth, commentController.updateComment);
router.delete('/:id', auth, commentController.deleteComment);
router.get('/deal/:dealId', commentController.getComments);
router.post('/:commentId/reply', auth, commentController.createReply);

module.exports = router;

================
File: src/routes/api/v1/Deal.Route.js
================
// File: src/routes/api/v1/Deal.Route.js

const express = require('express');
const router = express.Router();
const dealController = require('../../../controllers/dealController');
const userController = require('../../../controllers/userController');
const auth = require('../../../middleware/auth');
const multer = require('multer');
const commentController = require('../../../controllers/commentController');

const upload = multer({ 
  storage: multer.memoryStorage(),
  limits: {
    fileSize: 5 * 1024 * 1024 // limit file size to 5MB
  }
});

// Public routes
router.get('/', dealController.getDeals);
router.get('/search', dealController.searchDeals);
router.get('/categories', dealController.getCategories);
router.get('/stores', dealController.getStores);
router.get('/trending', dealController.getTrendingDeals);
router.get('/expiring-soon', dealController.getExpiringSoonDeals);

// Routes that require authentication
router.use(auth);

// Move the '/saved' route before the '/:id' route
router.get('/followed', dealController.getFollowedDeals);

router.get('/:id', dealController.getDeal);
router.get('/:id/comments', commentController.getComments);
router.get('/:id/status', dealController.checkDealStatus);

router.post('/', dealController.createDeal);
router.put('/:id', dealController.updateDeal);
router.delete('/:id', dealController.deleteDeal);
router.post('/:id/buy', dealController.markAsBought);
router.post('/:id/follow', dealController.followDeal);
router.delete('/:id/follow', dealController.unfollowDeal);
router.post('/:dealId/comments', auth, commentController.createComment);
router.get('/:dealId/comments', commentController.getComments);

// Image-related routes
router.post('/fetch-image', dealController.fetchImage);
router.post('/upload-image', upload.single('image'), dealController.uploadImage);

// New route to fetch mentionable users
router.get('/:id/mentionable-users', auth, dealController.getMentionableUsers);

module.exports = router;

================
File: src/routes/api/v1/index.js
================
const express = require('express');
const router = express.Router();

const userRoutes = require('./User.Route');
const dealRoutes = require('./Deal.Route');
const commentRoutes = require('./Comment.Route');
const adminRoutes = require('./Admin.Route');
const notificationRoutes = require('./Notification.Route');

router.use('/users', userRoutes);
router.use('/deals', dealRoutes);
router.use('/comments', commentRoutes);
router.use('/admin', adminRoutes);
router.use('/users/notifications', notificationRoutes);  // Change this line

module.exports = router;

================
File: src/routes/api/v1/Notification.Route.js
================
const express = require('express');
const router = express.Router();
const notificationController = require('../../../controllers/notificationController');
const auth = require('../../../middleware/auth');

router.use(auth);

router.get('/', notificationController.getNotifications);
router.patch('/:id/read', notificationController.markAsRead);
router.patch('/read-all', notificationController.markAllAsRead);
router.delete('/:id', notificationController.deleteNotification);

module.exports = router;

================
File: src/routes/api/v1/User.Route.js
================
const express = require('express');
const router = express.Router();
const userController = require('../../../controllers/userController');
const auth = require('../../../middleware/auth');
const multer = require('multer');

const upload = multer({ 
  storage: multer.memoryStorage(),
  limits: {
    fileSize: 5 * 1024 * 1024 // limit file size to 5MB
  }
});

// Auth routes
router.post('/register', userController.register);
router.post('/login', userController.login);
router.post('/logout', auth, userController.logout);

// Token validation route (place this before ID routes)
router.get('/validate-token', auth, userController.validateToken);

// Current user routes
router.get('/me', auth, userController.getCurrentUser);
router.put('/me', auth, userController.updateCurrentUser);

// Password reset routes
router.post('/forgot-password', userController.forgotPassword);
router.post('/verify-email', userController.verifyEmail);
router.post('/change-password', auth, userController.changePassword);

// Move these routes before the /:id routes
router.get('/me/following', auth, userController.getCurrentUserFollowing);
router.get('/me/followers', auth, userController.getCurrentUserFollowers);
router.get('/me/deals', auth, userController.getCurrentUserDeals);
router.get('/me/followed-deals', auth, userController.getCurrentUserFollowedDeals);
router.get('/me/collections', auth, userController.getCurrentUserCollections);
router.post('/me/collections', auth, userController.createCollection);
router.put('/me/collections/:id', auth, userController.updateCollection);
router.delete('/me/collections/:id', auth, userController.deleteCollection);
router.get('/me/activity', auth, userController.getCurrentUserActivity);

// New notification routes
router.get('/notifications', auth, userController.getUnreadNotifications);
router.patch('/notifications/:id/read', auth, userController.markNotificationAsRead);

// Then keep the /:id routes
router.get('/:id', userController.getUser);
router.get('/:id/deals', userController.getUserDeals);
router.get('/:id/followers', userController.getUserFollowers);
router.get('/:id/following', userController.getUserFollowing);
router.post('/:id/follow', auth, userController.followUser);
router.delete('/:id/follow', auth, userController.unfollowUser);
router.get('/:id/activity', userController.getUserActivity);
router.get('/:id/status', auth, userController.checkUserStatus);

// Add this new route
router.post('/upload-profile-picture', auth, upload.single('image'), userController.uploadProfilePicture);

module.exports = router;

================
File: src/routes/testRoutes.js
================
const express = require('express');
const router = express.Router();
const NotificationService = require('../services/NotificationService');

module.exports = function(io) {
  const notificationService = new NotificationService(io);

  router.post('/test-notification', async (req, res) => {
    console.log('Received request body:', req.body);
    try {
      const { recipientId, message } = req.body;
      if (!recipientId) {
        return res.status(400).json({ success: false, error: 'recipientId is required' });
      }
      const notification = await notificationService.createNotification({
        recipient: recipientId,
        content: message || 'This is a test notification',
        // The type will be set to 'SYSTEM' in the NotificationService
      });
      res.json({ success: true, notification });
    } catch (error) {
      console.error('Error in test notification route:', error);
      res.status(500).json({ success: false, error: error.message });
    }
  });

  return router;
};

================
File: src/server.js
================
require('dotenv').config();
const mongoose = require('mongoose');
const http = require('http');
const socketIo = require('socket.io');
const app = require('./app'); // Import the Express app from app.js

const PORT = process.env.PORT || 5000;

console.log('MONGODB_URI:', process.env.MONGODB_URI);

const server = http.createServer(app);
const io = socketIo(server, {
  cors: {
    origin: ["https://deals.ishay.me", "http://localhost:3000"],
    methods: ["GET", "POST"],
    credentials: true
  }
});

const testRoutes = require('./routes/testRoutes')(io);

io.on('connection', (socket) => {
  console.log('New client connected', socket.id);
  
  socket.on('join', ({ userId }) => {
    console.log(`User ${userId} joining room`);
    socket.join(userId);
  });

  socket.on('disconnect', () => {
    console.log('Client disconnected', socket.id);
  });

  socket.on('authenticate', (userId) => {
    socket.join(userId);
    console.log(`User ${userId} authenticated`);
  });

  socket.on('ping', () => {
    console.log('Received ping from', socket.id);
    socket.emit('pong');
  });

  socket.on('testConnection', (data) => {
    console.log('Received test connection from client', socket.id, data);
    socket.emit('testResponse', { message: 'Connection successful!' });
  });
});

app.set('io', io);

// Add the test routes to the main app
app.use('/api/test', testRoutes);

mongoose.connect(process.env.MONGODB_URI)
  .then(() => {
    console.log('Connected to MongoDB');
    server.listen(PORT, () => {
      console.log(`Server is running on port ${PORT}`);
    });
  })
  .catch(err => console.error('Could not connect to MongoDB', err));

================
File: src/services/imageFetcherService.js
================
const axios = require('axios');
const path = require('path');
const fs = require('fs-extra');
const crypto = require('crypto');
const cheerio = require('cheerio');

class ImageFetcherService {
  constructor() {
    this.imageDir = path.join(__dirname, '..', '..', 'public', 'images', 'deals');
    fs.ensureDirSync(this.imageDir);
    console.log('ImageFetcherService initialized. Image directory:', this.imageDir);
  }

  async fetchAndSaveImage(url) {
    try {
      console.log('Fetching image from URL:', url);
      
      // Fetch the page content
      const pageResponse = await axios.get(url, {
        headers: {
          'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36'
        }
      });
      
      const $ = cheerio.load(pageResponse.data);
      
      // Try to find the main image URL
      let imageUrl = this.findImageUrl($, url);

      if (!imageUrl) {
        throw new Error('No suitable image found on the page');
      }

      console.log('Found image URL:', imageUrl);

      // Ensure the image URL is absolute
      imageUrl = new URL(imageUrl, url).href;

      console.log('Resolved image URL:', imageUrl);

      // Fetch the actual image
      const imageResponse = await axios.get(imageUrl, { 
        responseType: 'arraybuffer',
        timeout: 10000,
        headers: {
          'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36'
        }
      });

      console.log('Image fetched successfully');

      const buffer = Buffer.from(imageResponse.data, 'binary');
      const filename = `${crypto.randomBytes(16).toString('hex')}.jpg`;
      const filepath = path.join(this.imageDir, filename);

      console.log('Writing image to file:', filepath);
      await fs.writeFile(filepath, buffer);
      
      console.log('Image saved successfully');
      const savedImageUrl = `/images/deals/${filename}`;
      console.log('Returning image URL:', savedImageUrl);
      return savedImageUrl;
    } catch (error) {
      console.error('Detailed error in fetchAndSaveImage:', error);
      if (error.response) {
        console.error('Error response:', error.response.status, error.response.statusText);
        console.error('Error data:', error.response.data);
      }
      return null;
    }
  }

  findImageUrl($, pageUrl) {
    // Check if it's an Amazon URL
    if (pageUrl.includes('amazon.com')) {
      return this.getAmazonImageUrl($);
    }

    // Generic image finding logic
    return $('meta[property="og:image"]').attr('content') ||
           $('meta[name="twitter:image"]').attr('content') ||
           $('link[rel="image_src"]').attr('href') ||
           $('img[itemprop="image"]').attr('src') ||
           $('img').first().attr('src');
  }

  getAmazonImageUrl($) {
    return $('#landingImage').attr('data-old-hires') ||
           $('#imgBlkFront').attr('src') ||
           $('#ebooksImgBlkFront').attr('src') ||
           $('img[data-old-hires]').attr('data-old-hires') ||
           $('img[data-a-dynamic-image]').attr('src');
  }
}

module.exports = ImageFetcherService;

================
File: src/services/NotificationService.js
================
// File: services/NotificationService.js

const Notification = require('../models/Notification.Model');

class NotificationService {
  constructor(io) {
    this.io = io;
  }

  async createNotification(data) {
    try {
      const notification = new Notification({
        recipient: data.recipient,
        type: data.type,
        content: data.content,
        relatedUser: data.relatedUser,
        relatedDeal: data.relatedDeal,
        relatedComment: data.relatedComment // Make sure this is set for comment notifications
      });
      await notification.save();
      console.log('New notification created:', notification);
      this.sendNotification(notification);
      return notification;
    } catch (error) {
      console.error('Error creating notification:', error);
      throw error;
    }
  }

  sendNotification(notification) {
    console.log('Sending notification to user:', notification.recipient.toString());
    this.io.to(notification.recipient.toString()).emit('newNotification', notification);
  }

  async createFollowNotification(followerId, followedId) {
    return this.createNotification({
      recipient: followedId,
      type: 'USER_FOLLOW', // Change this from 'FOLLOW' to 'USER_FOLLOW'
      content: 'You have a new follower!',
      relatedUser: followerId
    });
  }

  async createCommentNotification(commenterId, dealOwnerId, dealId) {
    return this.createNotification({
      recipient: dealOwnerId,
      type: 'COMMENT',
      content: 'Someone commented on your deal!',
      relatedUser: commenterId,
      relatedDeal: dealId
    });
  }

  async createDealFollowNotification(followerId, dealOwnerId, dealId) {
    return this.createNotification({
      recipient: dealOwnerId,
      type: 'DEAL_FOLLOW',
      content: 'Someone followed your deal!',
      relatedUser: followerId,
      relatedDeal: dealId
    });
  }

  async getUnreadNotifications(userId) {
    try {
      console.log('Fetching unread notifications for user:', userId);
      
      // Log the query
      console.log('Query:', { recipient: userId, read: false });
      
      // Execute the find operation separately
      const query = Notification.find({ recipient: userId, read: false })
        .sort({ createdAt: -1 });
      console.log('Query object:', query);
      
      // Execute population separately
      const populatedQuery = query
        .populate('relatedUser', 'username profilePicture')
        .populate('relatedDeal', 'title')
        .populate('relatedComment', 'content');
      console.log('Populated query object:', populatedQuery);
      
      // Execute the query
      const notifications = await populatedQuery.lean();
      
      console.log('Fetched notifications:', JSON.stringify(notifications, null, 2));
      return notifications;
    } catch (error) {
      console.error('Error fetching unread notifications:', error);
      throw error;
    }
  }

  async markAsRead(notificationId) {
    try {
      const notification = await Notification.findByIdAndUpdate(
        notificationId,
        { read: true },
        { new: true }
      );
      return notification;
    } catch (error) {
      console.error('Error marking notification as read:', error);
      throw error;
    }
  }

  async createMentionNotification(mentionedById, mentionedUserId, dealId, commentId) {
    console.log('Creating mention notification:', { mentionedById, mentionedUserId, dealId, commentId });
    return this.createNotification({
      recipient: mentionedUserId,
      type: 'MENTION',
      content: 'You were mentioned in a comment',
      relatedUser: mentionedById,
      relatedDeal: dealId,
      relatedComment: commentId
    });
  }

  async markAllAsRead(userId) {
    try {
      const result = await Notification.updateMany(
        { recipient: userId, read: false },
        { $set: { read: true } }
      );
      
      // Fetch the updated notifications
      const updatedNotifications = await Notification.find({ recipient: userId });
      
      // Emit socket events for each updated notification
      updatedNotifications.forEach(notification => {
        this.io.to(userId.toString()).emit('updateNotification', notification);
      });

      return result;
    } catch (error) {
      console.error('Error marking all notifications as read:', error);
      throw error;
    }
  }
}

module.exports = NotificationService;

================
File: src/testImageFetcher.js
================
const ImageFetcherService = require('./services/imageFetcherService');

async function testImageFetcher() {
  const testUrls = [
    'https://he.aliexpress.com/item/1005004763702938.html?spm=a2g0o.tm1000007309.2459882340.dundefined.54f76f3dyxh01R&pdp_ext_f=%7B%22ship_from%22:%22CN%22,%22sku_id%22:%2212000035244868987%22%7D&pdp_npi=4%40dis%21ILS%21%E2%82%AA%20114.34%21%E2%82%AA%2038.08%21%21%2129.97%219.98%21%402103085c17263319782914988ed468%2112000035244868987%21gdf%21IL%211657335144%21X&aecmd=true',
    'https://www.amazon.co.uk/Columbia-Classics-Collection-Blu-ray-Region/dp/B0DBH9NKMN/ref=sr_1_1?crid=YXGIJLRSHTSV&dib=eyJ2IjoiMSJ9.44NZBkQ3nrt6hHgj1dycKlkV8A9kw8aakrdJYBmvrGDjrwjmr2VkQidqe1p5P5uJAANn9p8QKQvL6DPOO9Y89HxCGwVFSDiINmtrNmrXSfsTkooFQn2Eq7Umhd8AScCG6-vJPgrmLiGRbWTF77xkXyKMlh6X5PDMNyReZNgGPCMDE3yf-L-9qfL4adQeBaAB.I72NBnAR_XQvXPS1F81_V25PF-7F-mUFAuW7EG9B4Rc&dib_tag=se&keywords=columbia+classics+4k+volume+5&qid=1726332076&sprefix=columbia%2Caps%2C158&sr=8-1',
    'https://www.ebay.com/itm/334109845538?_trksid=p4375194.c101800.m5481',
    'https://www.lastprice.co.il/p/100004176/%D7%9E%D7%99%D7%A7%D7%A1%D7%A8%2D%D7%9E%D7%A7%D7%A6%D7%95%D7%A2%D7%99%2D4.8%2D%D7%9C%D7%99%D7%98%D7%A8%2DKitchenAid/KitchenAid-Artisan%2D5KSM125EAC%2D%D7%A9%D7%A7%D7%93'
  ];

  const imageFetcher = new ImageFetcherService();

  for (const url of testUrls) {
    console.log(`\nTesting URL: ${url}`);
    try {
      const imageUrl = await imageFetcher.fetchImageUrl(url);
      console.log('Image URL:', imageUrl);
    } catch (error) {
      console.error('Error fetching image URL:', error.message);
    }
    console.log('-------------------');
  }
}

testImageFetcher();

================
File: src/utils/appError.js
================
class AppError extends Error {
    constructor(message, statusCode) {
      super(message);
      this.statusCode = statusCode;
      this.status = `${statusCode}`.startsWith('4') ? 'fail' : 'error';
      this.isOperational = true;

      Error.captureStackTrace(this, this.constructor);
    }
  }

  module.exports = AppError;

================
File: src/utils/catchAsync.js
================
module.exports = fn => {
    return (req, res, next) => {
      fn(req, res, next).catch(next);
    };
  };
