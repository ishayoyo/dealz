This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repopack on: 2024-09-17T11:23:08.138Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repopack's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

For more information about Repopack, visit: https://github.com/yamadashy/repopack

================================================================
Repository Structure
================================================================
.gitignore
package.json
src/app.js
src/config/config.js
src/controllers/adminController.js
src/controllers/commentController.js
src/controllers/dealController.js
src/controllers/userController.js
src/middleware/auth.js
src/middleware/isAdmin.js
src/middleware/rateLimit.js
src/models/Comment.Model.js
src/models/Deal.Model.js
src/models/Follow.Model.js
src/models/User.Model.js
src/models/Vote.Model.js
src/routes/api/v1/Admin.Route.js
src/routes/api/v1/Comment.Route.js
src/routes/api/v1/Deal.Route.js
src/routes/api/v1/index.js
src/routes/api/v1/User.Route.js
src/routes/api/v1/Vote.Model.js
src/server.js
src/services/imageFetcherService.js
src/testImageFetcher.js
src/utils/appError.js
src/utils/catchAsync.js

================================================================
Repository Files
================================================================

================
File: .gitignore
================
node_modules/
.env

================
File: package.json
================
{
  "name": "backend",
  "version": "1.0.0",
  "main": "src/server.js",
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1",
    "start": "node src/server.js",
    "dev": "nodemon src/server.js"
  },
  "keywords": [],
  "author": "",
  "license": "ISC",
  "dependencies": {
    "@azure/cognitiveservices-imagesearch": "^3.0.1",
    "@azure/ms-rest-azure-js": "^2.1.0",
    "axios": "^1.7.7",
    "bcryptjs": "^2.4.3",
    "cheerio": "^1.0.0",
    "compression": "^1.7.4",
    "cors": "^2.8.5",
    "dotenv": "^16.4.5",
    "express": "^4.21.0",
    "express-mongo-sanitize": "^2.2.0",
    "express-rate-limit": "^7.4.0",
    "fs-extra": "^11.2.0",
    "helmet": "^7.1.0",
    "hpp": "^0.2.3",
    "ioredis": "^5.4.1",
    "jsonwebtoken": "^9.0.2",
    "mongoose": "^8.6.2",
    "morgan": "^1.10.0",
    "multer": "^1.4.5-lts.1",
    "puppeteer": "^23.3.0",
    "puppeteer-extra": "^3.3.6",
    "puppeteer-extra-plugin-stealth": "^2.11.2",
    "sharp": "^0.33.5",
    "xss-clean": "^0.1.4"
  },
  "devDependencies": {
    "nodemon": "^3.1.4"
  },
  "description": ""
}

================
File: src/app.js
================
const express = require('express');
const cors = require('cors');
const path = require('path');
const routes = require('./routes/api/v1');

const app = express();

app.use(cors({
  origin: 'http://localhost:3000', // or whatever port your frontend is running on
  credentials: true
}));
app.use(express.json());

// Serve static files from the 'public' directory
app.use('/images', express.static(path.join(__dirname, '../public/images')));

app.use('/api/v1', routes);

// Global error handler
app.use((err, req, res, next) => {
  console.error(err.stack);
  res.status(500).json({ message: 'Something went wrong!' });
});

module.exports = app;

================
File: src/config/config.js
================
require('dotenv').config();

module.exports = {
  port: process.env.PORT || 5000,
  mongoUri: process.env.MONGO_URI,
  // Add other configuration variables as needed
};

================
File: src/controllers/adminController.js
================
const User = require('../models/User.Model');
const Deal = require('../models/Deal.Model');
const Comment = require('../models/Comment.Model');
const AppError = require('../utils/appError');
const catchAsync = require('../utils/catchAsync');

exports.getUsers = catchAsync(async (req, res, next) => {
  const users = await User.find().select('-password');

  res.status(200).json({
    status: 'success',
    results: users.length,
    data: { users }
  });
});

exports.updateUser = catchAsync(async (req, res, next) => {
  const user = await User.findByIdAndUpdate(req.params.id, req.body, {
    new: true,
    runValidators: true
  }).select('-password');

  if (!user) {
    return next(new AppError('No user found with that ID', 404));
  }

  res.status(200).json({
    status: 'success',
    data: { user }
  });
});

exports.deleteUser = catchAsync(async (req, res, next) => {
  const user = await User.findByIdAndDelete(req.params.id);

  if (!user) {
    return next(new AppError('No user found with that ID', 404));
  }

  res.status(204).json({
    status: 'success',
    data: null
  });
});

exports.getDeals = catchAsync(async (req, res, next) => {
  const deals = await Deal.find().populate('user', 'username');

  res.status(200).json({
    status: 'success',
    results: deals.length,
    data: { deals }
  });
});

exports.updateDeal = catchAsync(async (req, res, next) => {
  const deal = await Deal.findByIdAndUpdate(req.params.id, req.body, {
    new: true,
    runValidators: true
  });

  if (!deal) {
    return next(new AppError('No deal found with that ID', 404));
  }

  res.status(200).json({
    status: 'success',
    data: { deal }
  });
});

exports.deleteDeal = catchAsync(async (req, res, next) => {
  const deal = await Deal.findByIdAndDelete(req.params.id);

  if (!deal) {
    return next(new AppError('No deal found with that ID', 404));
  }

  res.status(204).json({
    status: 'success',
    data: null
  });
});

exports.getStats = catchAsync(async (req, res, next) => {
  const userCount = await User.countDocuments();
  const dealCount = await Deal.countDocuments();
  const commentCount = await Comment.countDocuments();

  res.status(200).json({
    status: 'success',
    data: {
      userCount,
      dealCount,
      commentCount
    }
  });
});

// More admin methods as needed

================
File: src/controllers/commentController.js
================
const Comment = require('../models/Comment.Model');
const Deal = require('../models/Deal.Model');
const AppError = require('../utils/appError');
const catchAsync = require('../utils/catchAsync');

exports.createComment = catchAsync(async (req, res, next) => {
  const comment = await Comment.create({
    content: req.body.content,
    user: req.user.id,
    deal: req.params.dealId
  });

  res.status(201).json({ status: 'success', data: { comment } });
});

exports.getComment = catchAsync(async (req, res, next) => {
  const comment = await Comment.findById(req.params.id).populate('user', 'username profilePicture');
  
  if (!comment) {
    return next(new AppError('No comment found with that ID', 404));
  }

  res.status(200).json({ status: 'success', data: { comment } });
});

exports.updateComment = catchAsync(async (req, res, next) => {
  const comment = await Comment.findOneAndUpdate(
    { _id: req.params.id, user: req.user.id },
    { content: req.body.content },
    { new: true, runValidators: true }
  );

  if (!comment) {
    return next(new AppError('No comment found with that ID or you are not authorized', 404));
  }

  res.status(200).json({ status: 'success', data: { comment } });
});

exports.deleteComment = catchAsync(async (req, res, next) => {
  const comment = await Comment.findOneAndDelete({ _id: req.params.id, user: req.user.id });

  if (!comment) {
    return next(new AppError('No comment found with that ID or you are not authorized', 404));
  }

  res.status(204).json({ status: 'success', data: null });
});

================
File: src/controllers/dealController.js
================
// File: src/controllers/dealController.js

const Deal = require('../models/Deal.Model');
const User = require('../models/User.Model');
const Comment = require('../models/Comment.Model');
const Vote = require('../models/Vote.Model');
const AppError = require('../utils/appError');
const catchAsync = require('../utils/catchAsync');
const ImageFetcherService = require('../services/imageFetcherService');
const sharp = require('sharp');
const path = require('path');
const fs = require('fs').promises;

exports.getDeals = catchAsync(async (req, res, next) => {
  const page = parseInt(req.query.page, 10) || 1;
  const limit = parseInt(req.query.limit, 10) || 10;
  const skip = (page - 1) * limit;

  const deals = await Deal.find({ status: 'active' })
    .sort('-createdAt')
    .skip(skip)
    .limit(limit)
    .populate('user', 'username profilePicture');

  const total = await Deal.countDocuments({ status: 'active' });

  res.status(200).json({
    status: 'success',
    results: deals.length,
    total,
    page,
    totalPages: Math.ceil(total / limit),
    data: { deals }
  });
});

exports.createDeal = catchAsync(async (req, res, next) => {
  const { title, description, price, originalPrice, url, store, category, tags, imageUrl, link } = req.body;

  if (!imageUrl) {
    return next(new AppError('Image URL is required', 400));
  }

  const dealUrl = url || link;

  if (!dealUrl) {
    return next(new AppError('URL is required', 400));
  }

  const deal = await Deal.create({
    title,
    description,
    price,
    originalPrice,
    url: dealUrl,
    imageUrl,
    store,
    category,
    tags,
    user: req.user.id
  });

  res.status(201).json({
    status: 'success',
    data: { deal }
  });
});

exports.getDeal = catchAsync(async (req, res, next) => {
  const deal = await Deal.findById(req.params.id)
    .populate('user', 'username profilePicture')
    .populate({
      path: 'comments',
      populate: { path: 'user', select: 'username profilePicture' }
    });

  if (!deal) {
    return next(new AppError('No deal found with that ID', 404));
  }

  res.status(200).json({
    status: 'success',
    data: { deal }
  });
});

exports.updateDeal = catchAsync(async (req, res, next) => {
  const deal = await Deal.findById(req.params.id);

  if (!deal) {
    return next(new AppError('No deal found with that ID', 404));
  }

  if (deal.user.toString() !== req.user.id && req.user.role !== 'admin') {
    return next(new AppError('You do not have permission to perform this action', 403));
  }

  Object.assign(deal, req.body);
  await deal.save();

  res.status(200).json({
    status: 'success',
    data: { deal }
  });
});

exports.deleteDeal = catchAsync(async (req, res, next) => {
  const deal = await Deal.findById(req.params.id);

  if (!deal) {
    return next(new AppError('No deal found with that ID', 404));
  }

  if (deal.user.toString() !== req.user.id && req.user.role !== 'admin') {
    return next(new AppError('You do not have permission to perform this action', 403));
  }

  await deal.deleteOne();

  res.status(204).json({
    status: 'success',
    data: null
  });
});

exports.voteDeal = catchAsync(async (req, res, next) => {
  const { id } = req.params;
  const { value } = req.body;

  const deal = await Deal.findById(id);

  if (!deal) {
    return next(new AppError('No deal found with that ID', 404));
  }

  let vote = await Vote.findOne({ user: req.user.id, deal: id });

  if (vote) {
    vote.value = value;
    await vote.save();
  } else {
    vote = await Vote.create({ user: req.user.id, deal: id, value });
  }

  const voteCount = await Vote.aggregate([
    { $match: { deal: deal._id } },
    { $group: { _id: null, total: { $sum: '$value' } } }
  ]);

  deal.voteCount = voteCount.length > 0 ? voteCount[0].total : 0;
  await deal.save();

  res.status(200).json({
    status: 'success',
    data: { voteCount: deal.voteCount }
  });
});

exports.addComment = catchAsync(async (req, res, next) => {
  const { id } = req.params;
  const { content } = req.body;

  const deal = await Deal.findById(id);

  if (!deal) {
    return next(new AppError('No deal found with that ID', 404));
  }

  const comment = await Comment.create({
    content,
    user: req.user.id,
    deal: id
  });

  res.status(201).json({
    status: 'success',
    data: { comment }
  });
});

exports.getDealComments = catchAsync(async (req, res, next) => {
  const deal = await Deal.findById(req.params.id).populate({
    path: 'comments',
    populate: { path: 'user', select: 'username profilePicture' }
  });

  if (!deal) {
    return next(new AppError('No deal found with that ID', 404));
  }

  res.status(200).json({
    status: 'success',
    data: { comments: deal.comments }
  });
});

exports.searchDeals = catchAsync(async (req, res, next) => {
  const { query, category, store, minPrice, maxPrice } = req.query;

  const searchCriteria = { status: 'active' };

  if (query) {
    searchCriteria.$text = { $search: query };
  }

  if (category) {
    searchCriteria.category = category;
  }

  if (store) {
    searchCriteria.store = store;
  }

  if (minPrice || maxPrice) {
    searchCriteria.price = {};
    if (minPrice) searchCriteria.price.$gte = parseFloat(minPrice);
    if (maxPrice) searchCriteria.price.$lte = parseFloat(maxPrice);
  }

  const deals = await Deal.find(searchCriteria)
    .sort('-createdAt')
    .populate('user', 'username profilePicture');

  res.status(200).json({
    status: 'success',
    results: deals.length,
    data: { deals }
  });
});

exports.getCategories = catchAsync(async (req, res, next) => {
  const categories = await Deal.distinct('category');
  res.status(200).json({
    status: 'success',
    data: { categories }
  });
});

exports.getStores = catchAsync(async (req, res, next) => {
  const stores = await Deal.distinct('store');
  res.status(200).json({
    status: 'success',
    data: { stores }
  });
});

exports.getTrendingDeals = catchAsync(async (req, res, next) => {
  const deals = await Deal.find({ status: 'active' })
    .sort('-voteCount -createdAt')
    .limit(10)
    .populate('user', 'username profilePicture');

  res.status(200).json({
    status: 'success',
    results: deals.length,
    data: { deals }
  });
});

exports.getExpiringSoonDeals = catchAsync(async (req, res, next) => {
  const now = new Date();
  const deals = await Deal.find({
    status: 'active',
    expiresAt: { $gt: now, $lt: new Date(now.getTime() + 24 * 60 * 60 * 1000) }
  })
    .sort('expiresAt')
    .limit(10)
    .populate('user', 'username profilePicture');

  res.status(200).json({
    status: 'success',
    results: deals.length,
    data: { deals }
  });
});

exports.markAsBought = catchAsync(async (req, res, next) => {
  const deal = await Deal.findById(req.params.id);
  if (!deal) {
    return next(new AppError('No deal found with that ID', 404));
  }

  const user = await User.findById(req.user.id);
  if (!user.boughtDeals.includes(deal._id)) {
    user.boughtDeals.push(deal._id);
    await user.save();
  }

  res.status(200).json({
    status: 'success',
    message: 'Deal marked as bought'
  });
});

exports.followDeal = catchAsync(async (req, res, next) => {
  const deal = await Deal.findById(req.params.id);
  if (!deal) {
    return next(new AppError('No deal found with that ID', 404));
  }

  const user = await User.findById(req.user.id);
  if (!user.followedDeals.includes(deal._id)) {
    user.followedDeals.push(deal._id);
    await user.save();
  }

  res.status(200).json({
    status: 'success',
    message: 'Deal followed successfully'
  });
});

exports.unfollowDeal = catchAsync(async (req, res, next) => {
  const deal = await Deal.findById(req.params.id);
  if (!deal) {
    return next(new AppError('No deal found with that ID', 404));
  }

  const user = await User.findById(req.user.id);
  user.followedDeals = user.followedDeals.filter(id => id.toString() !== deal._id.toString());
  await user.save();

  res.status(200).json({
    status: 'success',
    message: 'Deal unfollowed successfully'
  });
});

exports.fetchImage = catchAsync(async (req, res, next) => {
  const { url } = req.body;
    
  if (!url) {
    return next(new AppError('URL is required', 400));
  }

  const imageFetcher = new ImageFetcherService();
  const imageUrl = await imageFetcher.fetchAndSaveImage(url);

  if (!imageUrl) {
    return next(new AppError('Unable to fetch image for the provided URL', 404));
  }

  res.status(200).json({
    status: 'success',
    data: { imageUrl }
  });
});

exports.uploadImage = catchAsync(async (req, res, next) => {
  if (!req.file) {
    return next(new AppError('No file uploaded', 400));
  }

  const filename = `deal-${req.user.id}-${Date.now()}.jpeg`;
  const filepath = path.join(__dirname, '..', '..', 'public', 'images', 'deals', filename);

  await sharp(req.file.buffer)
    .resize(800, 600)
    .toFormat('jpeg')
    .jpeg({ quality: 90 })
    .toFile(filepath);

  const imageUrl = `/images/deals/${filename}`;

  res.status(200).json({
    status: 'success',
    data: { imageUrl }
  });
});

================
File: src/controllers/userController.js
================
const User = require('../models/User.Model');
const Deal = require('../models/Deal.Model');
const Follow = require('../models/Follow.Model');
const jwt = require('jsonwebtoken');
const bcrypt = require('bcryptjs');
const catchAsync = require('../utils/catchAsync');
const AppError = require('../utils/appError');

const signToken = id => {
  return jwt.sign({ id }, process.env.JWT_SECRET, {
    expiresIn: '1h' // This line is the fix
  });
};

exports.register = catchAsync(async (req, res, next) => {
  const { username, email, password } = req.body;

  // Check if user already exists
  const existingUser = await User.findOne({ $or: [{ email }, { username }] });
  if (existingUser) {
    return next(new AppError('User with this email or username already exists', 400));
  }

  const newUser = await User.create({ username, email, password });

  // Remove password from output
  newUser.password = undefined;

  const token = signToken(newUser._id);

  res.status(201).json({
    status: 'success',
    token,
    data: { user: newUser }
  });
});

exports.login = catchAsync(async (req, res, next) => {
  const { email, password } = req.body;
  if (!email || !password) {
    return next(new AppError('Please provide email and password', 400));
  }
  const user = await User.findOne({ email }).select('+password');
  if (!user || !(await user.comparePassword(password))) {
    return next(new AppError('Incorrect email or password', 401));
  }
  const token = signToken(user._id);
  res.status(200).json({ status: 'success', token });
});

exports.logout = (req, res) => {
  res.status(200).json({ status: 'success' });
};

exports.getCurrentUser = catchAsync(async (req, res, next) => {
  const user = await User.findById(req.user.id);
  res.status(200).json({ status: 'success', data: { user } });
});

exports.updateCurrentUser = catchAsync(async (req, res, next) => {
  const updatedUser = await User.findByIdAndUpdate(req.user.id, req.body, {
    new: true,
    runValidators: true
  });
  res.status(200).json({ status: 'success', data: { user: updatedUser } });
});

exports.getUser = catchAsync(async (req, res, next) => {
  const user = await User.findById(req.params.id);
  if (!user) {
    return next(new AppError('No user found with that ID', 404));
  }
  res.status(200).json({ status: 'success', data: { user } });
});

exports.getUserDeals = catchAsync(async (req, res, next) => {
  const deals = await Deal.find({ user: req.params.id });
  res.status(200).json({ status: 'success', data: { deals } });
});

exports.getUserFollowers = catchAsync(async (req, res, next) => {
  const followers = await Follow.find({ followed: req.params.id }).populate('follower');
  res.status(200).json({ status: 'success', data: { followers } });
});

exports.getUserFollowing = catchAsync(async (req, res, next) => {
  const following = await Follow.find({ follower: req.params.id }).populate('followed');
  res.status(200).json({ status: 'success', data: { following } });
});

exports.followUser = catchAsync(async (req, res, next) => {
  const follow = await Follow.create({
    follower: req.user.id,
    followed: req.params.id
  });
  res.status(201).json({ status: 'success', data: { follow } });
});

exports.unfollowUser = catchAsync(async (req, res, next) => {
  await Follow.findOneAndDelete({
    follower: req.user.id,
    followed: req.params.id
  });
  res.status(204).json({ status: 'success', data: null });
});

exports.forgotPassword = catchAsync(async (req, res, next) => {
  // Implement password reset logic here
  res.status(200).json({ status: 'success', message: 'Password reset email sent' });
});

exports.resetPassword = catchAsync(async (req, res, next) => {
  // Implement password reset logic here
  res.status(200).json({ status: 'success', message: 'Password reset successful' });
});

exports.verifyEmail = catchAsync(async (req, res, next) => {
  // Implement email verification logic here
  res.status(200).json({ status: 'success', message: 'Email verified successfully' });
});

================
File: src/middleware/auth.js
================
const jwt = require('jsonwebtoken');
const User = require('../models/User.Model');
const AppError = require('../utils/appError');
const catchAsync = require('../utils/catchAsync');

const auth = catchAsync(async (req, res, next) => {
  let token;
  if (req.headers.authorization && req.headers.authorization.startsWith('Bearer')) {
    token = req.headers.authorization.split(' ')[1];
  }

  if (!token) {
    return next(new AppError('You are not logged in. Please log in to get access.', 401));
  }

  const decoded = jwt.verify(token, process.env.JWT_SECRET);
  const user = await User.findById(decoded.id);

  if (!user) {
    return next(new AppError('The user belonging to this token no longer exists.', 401));
  }

  req.user = user;
  next();
});

module.exports = auth;

================
File: src/middleware/isAdmin.js
================
const isAdmin = (req, res, next) => {
    if (req.user && req.user.role === 'admin') {
      next();
    } else {
      res.status(403).json({ message: 'Access denied. Admin only.' });
    }
  };
  
  module.exports = isAdmin;

================
File: src/middleware/rateLimit.js
================
const rateLimit = {
  register: (req, res, next) => {
    console.log('Rate limit middleware for registration');
    next();
  },
  login: (req, res, next) => {
    console.log('Rate limit middleware for login');
    next();
  },
  forgotPassword: (req, res, next) => {
    console.log('Rate limit middleware for forgot password');
    next();
  },
  comment: (req, res, next) => {
    console.log('Rate limit middleware for comment');
    next();
  },
  createDeal: (req, res, next) => {
    console.log('Rate limit applied for deal creation');
    next();
  },
  vote: (req, res, next) => {
    console.log('Rate limit applied for voting');
    next();
  }
};

module.exports = rateLimit;

================
File: src/models/Comment.Model.js
================
const mongoose = require('mongoose');

const commentSchema = new mongoose.Schema({
  content: { type: String, required: true },
  user: { type: mongoose.Schema.Types.ObjectId, ref: 'User', required: true, index: true },
  deal: { type: mongoose.Schema.Types.ObjectId, ref: 'Deal', required: true, index: true },
  parentComment: { type: mongoose.Schema.Types.ObjectId, ref: 'Comment' },
  status: { type: String, enum: ['active', 'deleted'], default: 'active' }
}, { 
  timestamps: true,
  toJSON: { virtuals: true },
  toObject: { virtuals: true }
});

commentSchema.virtual('replies', {
  ref: 'Comment',
  localField: '_id',
  foreignField: 'parentComment'
});

module.exports = mongoose.model('Comment', commentSchema);

================
File: src/models/Deal.Model.js
================
// File: src/models/Deal.Model.js

const mongoose = require('mongoose');

const dealSchema = new mongoose.Schema({
  title: { type: String, required: true, index: 'text' },
  description: { type: String, index: 'text' },
  price: { type: Number, required: true },
  originalPrice: Number,
  currency: { type: String, default: 'USD' },
  url: { type: String, required: true },
  imageUrl: { type: String, required: true },
  userUploadedImage: { type: Boolean, default: false },
  store: { type: String, index: true },
  category: { type: String, index: true },
  user: { type: mongoose.Schema.Types.ObjectId, ref: 'User', required: true, index: true },
  status: { type: String, enum: ['active', 'expired', 'deleted'], default: 'active', index: true },
  expiresAt: Date,
  tags: [{ type: String, index: true }],
  metadata: {
    source: String,
    affiliate: Boolean,
    affiliateCode: String
  },
  priceHistory: [{
    price: Number,
    date: { type: Date, default: Date.now }
  }],
  analytics: {
    views: { type: Number, default: 0 },
    clicks: { type: Number, default: 0 },
    conversions: { type: Number, default: 0 }
  },
  location: {
    country: String,
    city: String
  },
  comments: [{ type: mongoose.Schema.Types.ObjectId, ref: 'Comment' }],
  votes: [{ type: mongoose.Schema.Types.ObjectId, ref: 'Vote' }]
}, { 
  timestamps: true,
  toJSON: { virtuals: true },
  toObject: { virtuals: true }
});

dealSchema.virtual('voteCount', {
  ref: 'Vote',
  localField: '_id',
  foreignField: 'deal',
  count: true
});

dealSchema.virtual('commentCount', {
  ref: 'Comment',
  localField: '_id',
  foreignField: 'deal',
  count: true
});

dealSchema.index({ title: 'text', description: 'text', tags: 'text' });

module.exports = mongoose.model('Deal', dealSchema);

================
File: src/models/Follow.Model.js
================
const mongoose = require('mongoose');

const followSchema = new mongoose.Schema({
  follower: { type: mongoose.Schema.Types.ObjectId, ref: 'User', required: true },
  followed: { type: mongoose.Schema.Types.ObjectId, ref: 'User', required: true }
}, { 
  timestamps: true 
});

followSchema.index({ follower: 1, followed: 1 }, { unique: true });

module.exports = mongoose.model('Follow', followSchema);

================
File: src/models/User.Model.js
================
const mongoose = require('mongoose');
const bcrypt = require('bcryptjs');

const userSchema = new mongoose.Schema({
  username: {
    type: String,
    required: [true, 'Please provide a username'],
    unique: true,
    trim: true,
  },
  email: {
    type: String,
    required: [true, 'Please provide an email'],
    unique: true,
    lowercase: true,
    trim: true,
  },
  password: {
    type: String,
    required: [true, 'Please provide a password'],
    minlength: 8,
    select: false,
  },
  profilePicture: String,
  bio: String,
  role: { type: String, enum: ['user', 'admin'], default: 'user' },
  isVerified: { type: Boolean, default: false },
  verificationToken: String,
  resetPasswordToken: String,
  resetPasswordExpires: Date,
  lastLogin: Date,
  preferences: {
    notifications: {
      email: { type: Boolean, default: true },
      push: { type: Boolean, default: true }
    },
    privacy: {
      showEmail: { type: Boolean, default: false },
      showActivity: { type: Boolean, default: true }
    }
  },
  socialProfiles: {
    facebook: String,
    twitter: String,
    instagram: String
  },
  reputation: { type: Number, default: 0 },
  badges: [String],
  favoriteCategories: [String],
  favoriteStores: [String],
  location: {
    country: String,
    city: String
  }
}, { 
  timestamps: true,
  toJSON: { virtuals: true },
  toObject: { virtuals: true }
});

userSchema.virtual('followersCount', {
  ref: 'Follow',
  localField: '_id',
  foreignField: 'followed',
  count: true
});

userSchema.virtual('followingCount', {
  ref: 'Follow',
  localField: '_id',
  foreignField: 'follower',
  count: true
});

userSchema.virtual('dealsCount', {
  ref: 'Deal',
  localField: '_id',
  foreignField: 'user',
  count: true
});

userSchema.pre('save', async function(next) {
  if (!this.isModified('password')) return next();
  this.password = await bcrypt.hash(this.password, 12);
  next();
});

userSchema.methods.comparePassword = async function(candidatePassword) {
  return await bcrypt.compare(candidatePassword, this.password);
};

const User = mongoose.model('User', userSchema);

module.exports = User;

================
File: src/models/Vote.Model.js
================
const mongoose = require('mongoose');

const voteSchema = new mongoose.Schema({
  user: { type: mongoose.Schema.Types.ObjectId, ref: 'User', required: true },
  deal: { type: mongoose.Schema.Types.ObjectId, ref: 'Deal', required: true },
  value: { type: Number, enum: [-1, 1], required: true }
}, { 
  timestamps: true 
});

voteSchema.index({ user: 1, deal: 1 }, { unique: true });

module.exports = mongoose.model('Vote', voteSchema);

================
File: src/routes/api/v1/Admin.Route.js
================
const express = require('express');
const router = express.Router();
const adminController = require('../../../controllers/adminController');
const auth = require('../../../middleware/auth');
const isAdmin = require('../../../middleware/isAdmin');

router.use(auth, isAdmin);

router.get('/users', adminController.getUsers);
router.put('/users/:id', adminController.updateUser);
router.delete('/users/:id', adminController.deleteUser);
router.get('/deals', adminController.getDeals);
router.put('/deals/:id', adminController.updateDeal);
router.delete('/deals/:id', adminController.deleteDeal);
router.get('/stats', adminController.getStats);

module.exports = router;

================
File: src/routes/api/v1/Comment.Route.js
================
const express = require('express');
const router = express.Router();
const commentController = require('../../../controllers/commentController');
const auth = require('../../../middleware/auth');

router.post('/:dealId', auth, commentController.createComment);
router.get('/:id', commentController.getComment);
router.put('/:id', auth, commentController.updateComment);
router.delete('/:id', auth, commentController.deleteComment);

module.exports = router;

================
File: src/routes/api/v1/Deal.Route.js
================
// File: src/routes/api/v1/Deal.Route.js

const express = require('express');
const router = express.Router();
const dealController = require('../../../controllers/dealController');
const auth = require('../../../middleware/auth');
const multer = require('multer');

const upload = multer({ 
  storage: multer.memoryStorage(),
  limits: {
    fileSize: 5 * 1024 * 1024 // limit file size to 5MB
  }
});

// Public routes
router.get('/', dealController.getDeals);
router.get('/search', dealController.searchDeals);
router.get('/categories', dealController.getCategories);
router.get('/stores', dealController.getStores);
router.get('/trending', dealController.getTrendingDeals);
router.get('/expiring-soon', dealController.getExpiringSoonDeals);
router.get('/:id', dealController.getDeal);
router.get('/:id/comments', dealController.getDealComments);

// Routes that require authentication
router.use(auth);

router.post('/', dealController.createDeal);
router.put('/:id', dealController.updateDeal);
router.delete('/:id', dealController.deleteDeal);
router.post('/:id/vote', dealController.voteDeal);
router.post('/:id/buy', dealController.markAsBought);
router.post('/:id/follow', dealController.followDeal);
router.delete('/:id/follow', dealController.unfollowDeal);
router.post('/:id/comments', dealController.addComment);

// Image-related routes
router.post('/fetch-image', dealController.fetchImage);
router.post('/upload-image', upload.single('image'), dealController.uploadImage);

module.exports = router;

================
File: src/routes/api/v1/index.js
================
const express = require('express');
const router = express.Router();

const userRoutes = require('./User.Route');
const dealRoutes = require('./Deal.Route');
const commentRoutes = require('./Comment.Route');
const adminRoutes = require('./Admin.Route');

router.use('/users', userRoutes);
router.use('/deals', dealRoutes);
router.use('/comments', commentRoutes);
router.use('/admin', adminRoutes);

module.exports = router;

================
File: src/routes/api/v1/User.Route.js
================
const express = require('express');
const router = express.Router();
const userController = require('../../../controllers/userController');
const auth = require('../../../middleware/auth');

router.post('/register', userController.register);
router.post('/login', userController.login);
router.post('/logout', auth, userController.logout);
router.get('/me', auth, userController.getCurrentUser);
router.put('/me', auth, userController.updateCurrentUser);
router.get('/:id', userController.getUser);
router.get('/:id/deals', userController.getUserDeals);
router.get('/:id/followers', userController.getUserFollowers);
router.get('/:id/following', userController.getUserFollowing);
router.post('/:id/follow', auth, userController.followUser);
router.delete('/:id/follow', auth, userController.unfollowUser);
router.post('/forgot-password', userController.forgotPassword);
router.post('/reset-password', userController.resetPassword);
router.post('/verify-email', userController.verifyEmail);

module.exports = router;

================
File: src/routes/api/v1/Vote.Model.js
================
const mongoose = require('mongoose');

const voteSchema = new mongoose.Schema({
  user: { type: mongoose.Schema.Types.ObjectId, ref: 'User', required: true },
  deal: { type: mongoose.Schema.Types.ObjectId, ref: 'Deal', required: true },
  value: { type: Number, enum: [-1, 0, 1], required: true }
}, { 
  timestamps: true 
});

voteSchema.index({ user: 1, deal: 1 }, { unique: true });

module.exports = mongoose.model('Vote', voteSchema);

================
File: src/server.js
================
require('dotenv').config();
const mongoose = require('mongoose');
const express = require('express');
const path = require('path');
const app = require('./app');

const PORT = process.env.PORT || 5000;

console.log('MONGODB_URI:', process.env.MONGODB_URI);

// Serve static files
app.use('/images', express.static(path.join(__dirname, '..', 'public', 'images')));

mongoose.connect(process.env.MONGODB_URI)
  .then(() => {
    console.log('Connected to MongoDB');
    app.listen(PORT, () => {
      console.log(`Server is running on port ${PORT}`);
    });
  })
  .catch(err => console.error('Could not connect to MongoDB', err));

================
File: src/services/imageFetcherService.js
================
const axios = require('axios');
const path = require('path');
const fs = require('fs-extra');
const crypto = require('crypto');
const cheerio = require('cheerio');

class ImageFetcherService {
  constructor() {
    this.imageDir = path.join(__dirname, '..', '..', 'public', 'images', 'deals');
    fs.ensureDirSync(this.imageDir);
    console.log('ImageFetcherService initialized. Image directory:', this.imageDir);
  }

  async fetchAndSaveImage(url) {
    try {
      console.log('Fetching image from URL:', url);
      
      // Fetch the page content
      const pageResponse = await axios.get(url, {
        headers: {
          'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36'
        }
      });
      
      const $ = cheerio.load(pageResponse.data);
      
      // Try to find the main image URL
      let imageUrl = this.findImageUrl($, url);

      if (!imageUrl) {
        throw new Error('No suitable image found on the page');
      }

      console.log('Found image URL:', imageUrl);

      // Ensure the image URL is absolute
      imageUrl = new URL(imageUrl, url).href;

      console.log('Resolved image URL:', imageUrl);

      // Fetch the actual image
      const imageResponse = await axios.get(imageUrl, { 
        responseType: 'arraybuffer',
        timeout: 10000,
        headers: {
          'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36'
        }
      });

      console.log('Image fetched successfully');

      const buffer = Buffer.from(imageResponse.data, 'binary');
      const filename = `${crypto.randomBytes(16).toString('hex')}.jpg`;
      const filepath = path.join(this.imageDir, filename);

      console.log('Writing image to file:', filepath);
      await fs.writeFile(filepath, buffer);
      
      console.log('Image saved successfully');
      const savedImageUrl = `/images/deals/${filename}`;
      console.log('Returning image URL:', savedImageUrl);
      return savedImageUrl;
    } catch (error) {
      console.error('Detailed error in fetchAndSaveImage:', error);
      if (error.response) {
        console.error('Error response:', error.response.status, error.response.statusText);
        console.error('Error data:', error.response.data);
      }
      return null;
    }
  }

  findImageUrl($, pageUrl) {
    // Check if it's an Amazon URL
    if (pageUrl.includes('amazon.com')) {
      return this.getAmazonImageUrl($);
    }

    // Generic image finding logic
    return $('meta[property="og:image"]').attr('content') ||
           $('meta[name="twitter:image"]').attr('content') ||
           $('link[rel="image_src"]').attr('href') ||
           $('img[itemprop="image"]').attr('src') ||
           $('img').first().attr('src');
  }

  getAmazonImageUrl($) {
    return $('#landingImage').attr('data-old-hires') ||
           $('#imgBlkFront').attr('src') ||
           $('#ebooksImgBlkFront').attr('src') ||
           $('img[data-old-hires]').attr('data-old-hires') ||
           $('img[data-a-dynamic-image]').attr('src');
  }
}

module.exports = ImageFetcherService;

================
File: src/testImageFetcher.js
================
const ImageFetcherService = require('./services/imageFetcherService');

async function testImageFetcher() {
  const testUrls = [
    'https://he.aliexpress.com/item/1005004763702938.html?spm=a2g0o.tm1000007309.2459882340.dundefined.54f76f3dyxh01R&pdp_ext_f=%7B%22ship_from%22:%22CN%22,%22sku_id%22:%2212000035244868987%22%7D&pdp_npi=4%40dis%21ILS%21%E2%82%AA%20114.34%21%E2%82%AA%2038.08%21%21%2129.97%219.98%21%402103085c17263319782914988ed468%2112000035244868987%21gdf%21IL%211657335144%21X&aecmd=true',
    'https://www.amazon.co.uk/Columbia-Classics-Collection-Blu-ray-Region/dp/B0DBH9NKMN/ref=sr_1_1?crid=YXGIJLRSHTSV&dib=eyJ2IjoiMSJ9.44NZBkQ3nrt6hHgj1dycKlkV8A9kw8aakrdJYBmvrGDjrwjmr2VkQidqe1p5P5uJAANn9p8QKQvL6DPOO9Y89HxCGwVFSDiINmtrNmrXSfsTkooFQn2Eq7Umhd8AScCG6-vJPgrmLiGRbWTF77xkXyKMlh6X5PDMNyReZNgGPCMDE3yf-L-9qfL4adQeBaAB.I72NBnAR_XQvXPS1F81_V25PF-7F-mUFAuW7EG9B4Rc&dib_tag=se&keywords=columbia+classics+4k+volume+5&qid=1726332076&sprefix=columbia%2Caps%2C158&sr=8-1',
    'https://www.ebay.com/itm/334109845538?_trksid=p4375194.c101800.m5481',
    'https://www.lastprice.co.il/p/100004176/%D7%9E%D7%99%D7%A7%D7%A1%D7%A8%2D%D7%9E%D7%A7%D7%A6%D7%95%D7%A2%D7%99%2D4.8%2D%D7%9C%D7%99%D7%98%D7%A8%2DKitchenAid/KitchenAid-Artisan%2D5KSM125EAC%2D%D7%A9%D7%A7%D7%93'
  ];

  const imageFetcher = new ImageFetcherService();

  for (const url of testUrls) {
    console.log(`\nTesting URL: ${url}`);
    try {
      const imageUrl = await imageFetcher.fetchImageUrl(url);
      console.log('Image URL:', imageUrl);
    } catch (error) {
      console.error('Error fetching image URL:', error.message);
    }
    console.log('-------------------');
  }
}

testImageFetcher();

================
File: src/utils/appError.js
================
class AppError extends Error {
    constructor(message, statusCode) {
      super(message);
      this.statusCode = statusCode;
      this.status = `${statusCode}`.startsWith('4') ? 'fail' : 'error';
      this.isOperational = true;

      Error.captureStackTrace(this, this.constructor);
    }
  }

  module.exports = AppError;

================
File: src/utils/catchAsync.js
================
module.exports = fn => {
    return (req, res, next) => {
      fn(req, res, next).catch(next);
    };
  };
