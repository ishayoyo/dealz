This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repopack on: 2024-09-26T19:20:49.134Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repopack's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

For more information about Repopack, visit: https://github.com/yamadashy/repopack

================================================================
Repository Structure
================================================================
.gitignore
app.vue
assets/css/tailwind.css
components/AuthModal.vue
components/Comment.vue
components/DealCard.vue
components/DealModal.vue
components/FollowedDeals.vue
components/Header.vue
components/NotificationList.vue
components/PostDealModal.vue
components/UserAvatar.vue
components/UserDeals.vue
components/UserMentionAutocomplete.vue
composables/useProfile.ts
composables/useSocket.js
layouts/default.vue
nuxt.config.ts
package.json
pages/index.vue
pages/notifications.vue
pages/profile.vue
plugins/auth-check.js
plugins/auth.js
plugins/fontawesome.js
plugins/socket.js
plugins/toast.js
plugins/userAvatar.js
public/robots.txt
README.md
server/tsconfig.json
services/api.js
stores/auth.js
stores/deals.js
stores/notification.js
tailwind.config.js
tsconfig.json

================================================================
Repository Files
================================================================

================
File: .gitignore
================
# Nuxt dev/build outputs
.output
.data
.nuxt
.nitro
.cache
dist

# Node dependencies
node_modules

# Logs
logs
*.log

# Misc
.DS_Store
.fleet
.idea

# Local env files
.env
.env.*
!.env.example

================
File: app.vue
================
<template>
  <NuxtLayout>
    <NuxtPage />
  </NuxtLayout>
</template>

<style>
@import 'tailwindcss/base';
@import 'tailwindcss/components';
@import 'tailwindcss/utilities';
</style>

================
File: assets/css/tailwind.css
================
@import url('https://fonts.googleapis.com/css2?family=Montserrat:wght@400;600;700&family=Inter:wght@400;500;600&display=swap');

@tailwind base;
@tailwind components;
@tailwind utilities;

@layer base {
  body {
    @apply bg-background text-text font-sans;
  }
  h1, h2, h3, h4, h5, h6 {
    @apply font-bold;
  }
}

@layer components {
  .btn {
    @apply font-semibold py-2 px-4 rounded-md transition duration-300 ease-in-out;
  }

  .btn-primary {
    @apply bg-primary text-white hover:bg-blue-600;
  }

  .btn-secondary {
    @apply bg-white text-primary border border-primary hover:bg-primary hover:text-white;
  }

  .btn-accent {
    @apply bg-accent text-white hover:bg-red-600;
  }

  .deal-card {
    @apply bg-white rounded-lg shadow-md hover:shadow-lg transition-shadow duration-300;
  }
}

================
File: components/AuthModal.vue
================
<template>
  <div class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
    <div class="bg-white rounded-lg w-full max-w-md p-8 relative">
      <button @click="$emit('close')" class="absolute top-4 right-4 text-gray-500 hover:text-gray-700">
        <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12" />
        </svg>
      </button>
      
      <h2 class="text-3xl font-bold mb-6 text-center text-blue-600">
        {{ isLogin ? 'Welcome Back!' : 'Join the Savings Squad!' }}
      </h2>
      
      <p class="text-center text-gray-600 mb-6">
        {{ isLogin ? 'Your fellow shoppers are waiting for your amazing deals!' : 'Unlock a world of incredible deals and start saving today!' }}
      </p>

      <form @submit.prevent="handleSubmit">
        <div class="mb-4" v-if="!isLogin">
          <label for="username" class="block text-gray-700 text-sm font-bold mb-2">Username</label>
          <input type="text" id="username" v-model="form.username" class="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500" required>
        </div>
        
        <div class="mb-4">
          <label for="email" class="block text-gray-700 text-sm font-bold mb-2">Email</label>
          <input 
            type="email" 
            id="email" 
            v-model="form.email" 
            autocomplete="username"
            class="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500" 
            required
          >
        </div>
        
        <div class="mb-6">
          <label for="password" class="block text-gray-700 text-sm font-bold mb-2">Password</label>
          <input type="password" id="password" v-model="form.password" autocomplete="current-password" class="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500" required>
        </div>
        
        <button type="submit" class="w-full bg-blue-600 text-white py-2 px-4 rounded-md hover:bg-blue-700 transition duration-300">
          {{ isLogin ? 'Log In' : 'Sign Up' }}
        </button>
      </form>
      
      <p class="mt-4 text-center text-gray-600">
        {{ isLogin ? "Don't have an account?" : "Already have an account?" }}
        <a href="#" @click.prevent="toggleAuthMode" class="text-blue-600 hover:underline">
          {{ isLogin ? 'Sign Up' : 'Log In' }}
        </a>
      </p>
      
      <div v-if="error" class="mt-4 text-red-500 text-center">
        {{ error }}
      </div>
    </div>
  </div>
</template>

<script setup>
import { ref, reactive, onMounted, watch } from 'vue'
import { useAuthStore } from '~/stores/auth'
import { useToast } from 'vue-toastification'
import { useRouter } from 'vue-router'

const authStore = useAuthStore()
const toast = useToast()
const router = useRouter()

const props = defineProps({
  isLogin: {
    type: Boolean,
    default: true
  }
})

const emit = defineEmits(['close', 'login', 'signup'])

const form = reactive({
  username: '',
  email: '',
  password: ''
})

const isLogin = ref(props.isLogin)
const error = ref(null)

const toggleAuthMode = () => {
  isLogin.value = !isLogin.value
  error.value = null
}

const handleSubmit = async () => {
  try {
    error.value = null
    if (isLogin.value) {
      // Change this line
      emit('login', { email: form.email, password: form.password })
    } else {
      // Change this line
      emit('signup', {
        username: form.username,
        email: form.email,
        password: form.password
      })
    }
    emit('close')
  } catch (err) {
    console.error('Auth error:', err)
    error.value = err.message || 'An error occurred. Please try again.'
    toast.error(error.value)
  }
}

// Watch for authentication state changes
watch(() => authStore.isAuthenticated, (newValue) => {
  if (!newValue) {
    // If user becomes unauthenticated (e.g., token expired), close the modal
    emit('close')
    // No need to redirect, as the auth store will handle it
  }
})

// Check authentication status on component mount
onMounted(() => {
  if (!authStore.isAuthenticated) {
    // If user is not authenticated, ensure they can't access protected routes
    const currentRoute = router.currentRoute.value
    if (currentRoute.meta.requiresAuth) {
      router.push('/')
    }
  }
})
</script>

================
File: components/Comment.vue
================
<template>
  <div class="comment">
    <div class="bg-gray-50 rounded-lg p-4">
      <div class="flex items-center mb-2">
        <UserAvatar :name="commentUsername" :size="32" class="mr-3" />
        <span class="font-semibold text-text">{{ commentUsername }}</span>
        <span class="text-sm text-gray-500 ml-2">{{ formatCommentDate(comment.createdAt) }}</span>
      </div>
      <p class="text-gray-600" v-html="formattedContent"></p>
      <div v-if="comment.replies && comment.replies.length > 0" class="mt-4 ml-4 space-y-2">
        <Comment v-for="reply in comment.replies" :key="reply._id" :comment="reply" :disable-voting="disableVoting" />
      </div>
    </div>
  </div>
</template>

<script setup>
import { computed } from 'vue'
import { useAuthStore } from '~/stores/auth'

const props = defineProps({
  comment: {
    type: Object,
    required: true
  },
  disableVoting: {
    type: Boolean,
    default: false
  }
})

const authStore = useAuthStore()

const commentUsername = computed(() => {
  if (props.comment.user && props.comment.user.username) {
    return props.comment.user.username
  }
  return authStore.user ? authStore.user.username : 'Anonymous'
})

const formatCommentDate = (date) => {
  return new Date(date).toLocaleString()
}

const formattedContent = computed(() => {
  return props.comment.content.replace(/@(\w+)/g, '<span class="mention">@$1</span>')
})
</script>

<style scoped>
.comment :deep(.mention) {
  color: #3b82f6; /* text-blue-500 */
  font-weight: 600; /* font-semibold */
}
</style>

================
File: components/DealCard.vue
================
<template>
  <div v-if="deal" class="bg-white rounded-lg shadow-md overflow-hidden hover:shadow-xl transition-all duration-300 transform hover:-translate-y-1" @click="openModal">
    <div class="relative pb-[56.25%]">
      <img :src="fullImageUrl" :alt="deal.title" class="absolute inset-0 w-full h-full object-cover">
      <div class="absolute top-0 right-0 bg-accent text-white px-3 py-1 m-2 rounded-full text-sm font-semibold">
        ${{ formattedPrice }}
      </div>
    </div>
    <div class="p-4">
      <h3 class="font-bold text-lg mb-2 text-text line-clamp-2">{{ deal.title || 'Untitled Deal' }}</h3>
      <p class="text-gray-600 text-sm mb-3 line-clamp-2">{{ deal.description || 'No description available' }}</p>
      <div class="flex items-center justify-between mb-3">
        <div class="flex items-center space-x-2">
          <UserAvatar :name="dealUsername" :size="24" />
          <span class="text-sm text-gray-500">{{ dealUsername }}</span>
        </div>
      </div>
      <div class="flex justify-between items-center">
        <span class="text-sm text-gray-500">
          <i class="far fa-clock mr-1"></i>{{ formattedDate }}
        </span>
        <button class="btn btn-primary">
          View Deal
        </button>
      </div>
    </div>
  </div>
</template>

<script setup>
import { computed } from 'vue'
import { useRuntimeConfig } from '#app'
import { format } from 'date-fns'

const config = useRuntimeConfig()

const props = defineProps({
  deal: {
    type: Object,
    required: true
  }
})

const emit = defineEmits(['open-modal'])

const fullImageUrl = computed(() => {
  if (!props.deal?.imageUrl) return '/default-deal-image.jpg'
  return props.deal.imageUrl.startsWith('http') 
    ? props.deal.imageUrl 
    : `${config.public.apiBase}${props.deal.imageUrl}`
})

const formattedPrice = computed(() => {
  return parseFloat(props.deal?.price || 0).toFixed(2)
})

const formattedDate = computed(() => {
  return format(new Date(props.deal?.createdAt || new Date()), 'MMM d, yyyy')
})

const dealUsername = computed(() => {
  return props.deal?.user?.username || 'Unknown User'
})

const openModal = () => {
  if (props.deal) {
    console.log('DealCard: Emitting open-modal event for deal:', props.deal)
    emit('open-modal', props.deal)
  }
}
</script>

================
File: components/DealModal.vue
================
<template>
  <div v-if="deal" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 p-4">
    <div class="bg-white rounded-lg w-full max-w-5xl overflow-hidden flex flex-col md:flex-row relative" :style="modalStyle">
      <!-- Close button -->
      <button @click="closeModal" class="absolute top-4 right-4 text-gray-700 hover:text-text z-20 bg-white rounded-full p-2 shadow-md transition duration-300">
        <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12" />
        </svg>
      </button>

      <!-- Left column: Image -->
      <div ref="imageContainer" class="w-full md:w-1/2 flex items-center justify-center p-4 bg-gray-100">
        <img :src="imageUrl" :alt="deal.title" @load="onImageLoad" class="max-w-full max-h-full object-contain rounded-lg shadow-md">
      </div>
      
      <!-- Right column: Content -->
      <div class="w-full md:w-1/2 p-6 overflow-y-auto">
        <h2 class="text-2xl font-bold mb-2 text-text">{{ deal.title }}</h2>
        <p class="text-gray-600 mb-4">{{ deal.description }}</p>
        
        <div class="flex items-center justify-between mb-4">
          <span class="font-bold text-accent text-2xl">${{ formattedPrice }}</span>
          <a :href="deal.url" target="_blank" rel="noopener noreferrer" class="btn btn-secondary">
            Go to Deal
          </a>
        </div>
        
        <div class="flex items-center space-x-4 mb-4">
          <button @click="handleFollowDeal" class="btn btn-primary">
            {{ isFollowing ? 'Unfollow' : 'Follow' }} Deal
          </button>
          <span class="text-sm text-gray-500">
            {{ formattedFollowCount }} {{ formattedFollowCount === 1 ? 'follower' : 'followers' }}
          </span>
        </div>
        
        <div v-if="deal.user" class="mb-6 flex items-center">
          <UserAvatar :name="dealUserName" :size="40" class="mr-3" />
          <div class="flex-grow">
            <span class="text-sm text-gray-500">Posted by:</span>
            <span class="font-semibold ml-1 text-text">{{ dealUserName }}</span>
          </div>
          <button 
            @click="handleFollowUser" 
            class="btn btn-primary text-sm"
            :disabled="isCurrentUser"
            :class="{ 'opacity-50 cursor-not-allowed': isCurrentUser }"
          >
            {{ isFollowingUser ? 'Unfollow' : 'Follow' }}
          </button>
        </div>
        
        <div class="border-t border-gray-200 pt-4">
          <h3 class="font-bold text-xl mb-4 text-text">Comments</h3>
          <div v-if="isAuthenticated">
            <div v-if="loading" class="text-gray-500">Loading comments...</div>
            <div v-else-if="error" class="text-red-500">{{ error }}</div>
            <div v-else class="comments-container space-y-4 mb-6">
              <div v-if="comments.length === 0" class="text-gray-500">No comments yet. Be the first to comment!</div>
              <div v-else>
                <Comment v-for="comment in comments" :key="comment._id" :comment="comment" />
              </div>
            </div>
            <div class="mt-4 relative">
              <textarea
                v-model="newComment"
                class="w-full px-4 py-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-primary focus:border-transparent"
                rows="3"
                placeholder="Add a comment..."
                @input="handleInput"
              ></textarea>
              <UserMentionAutocomplete
                v-if="showMentions"
                :users="mentionableUsers"
                :query="mentionQuery"
                @select="handleUserSelect"
              />
            </div>
            <button @click="handleAddComment" class="btn btn-primary mt-2">
              Add Comment
            </button>
          </div>
          <div v-else class="text-center py-4">
            <p>Login to view comments</p>
            <button @click="openAuthModal" class="mt-2 btn btn-primary">Login</button>
          </div>
        </div>
      </div>
    </div>
  </div>
</template>

<script setup>
import { ref, onMounted, watch, computed } from 'vue'
import { useRuntimeConfig } from '#app'
import api from '~/services/api'
import { useToast } from "vue-toastification"
import { useAuthStore } from '~/stores/auth'
import { useDealsStore } from '~/stores/deals'
import Comment from '~/components/Comment.vue'
import UserMentionAutocomplete from '~/components/UserMentionAutocomplete.vue'

const props = defineProps({
  deal: {
    type: Object,
    required: true
  }
})

const emit = defineEmits(['close-modal', 'open-auth-modal'])

const config = useRuntimeConfig()
const authStore = useAuthStore()
const dealsStore = useDealsStore()
const toast = useToast()

const comments = ref([])
const isFollowing = ref(false)
const isFollowingUser = ref(false)
const newComment = ref('')
const loading = ref(false)
const error = ref(null)
const mentionableUsers = ref([])
const mentionQuery = ref('')
const showMentions = ref(false)
const imageContainer = ref(null)
const modalStyle = ref({})

const isAuthenticated = computed(() => authStore.isAuthenticated)

const imageUrl = computed(() => {
  if (!props.deal.imageUrl) return ''
  return props.deal.imageUrl.startsWith('http') 
    ? props.deal.imageUrl 
    : `${config.public.apiBase}${props.deal.imageUrl}`
})

const formattedPrice = computed(() => {
  return parseFloat(props.deal.price).toFixed(2)
})

const formattedFollowCount = computed(() => {
  return props.deal.followCount || 0
})

const isCurrentUser = computed(() => {
  return authStore.user && props.deal.user && authStore.user._id === props.deal.user._id
})

const dealUserName = computed(() => {
  return props.deal.user && props.deal.user.username ? props.deal.user.username : 'Anonymous'
})

const fetchDealData = async () => {
  loading.value = true
  error.value = null
  try {
    const [commentsResponse, statusResponse, userStatusResponse] = await Promise.all([
      api.get(`/comments/deal/${props.deal._id}`),
      isAuthenticated.value ? api.get(`/deals/${props.deal._id}/status`) : Promise.resolve({ data: { data: { isFollowing: false } } }),
      isAuthenticated.value && props.deal.user ? api.get(`/users/${props.deal.user._id}/status`) : Promise.resolve({ data: { data: { isFollowing: false } } })
    ])
    
    comments.value = commentsResponse.data.data.comments
    if (isAuthenticated.value) {
      isFollowing.value = statusResponse.data.data.isFollowing
      isFollowingUser.value = userStatusResponse.data.data.isFollowing
    } else {
      isFollowing.value = false
      isFollowingUser.value = false
    }
  } catch (err) {
    console.error('Error fetching deal data:', err)
    error.value = 'Failed to load data. Please try again.'
    toast.error(error.value)
  } finally {
    loading.value = false
  }
}

const fetchMentionableUsers = async () => {
  try {
    const response = await api.get(`/deals/${props.deal._id}/mentionable-users`)
    mentionableUsers.value = response.data.data.users
  } catch (err) {
    console.error('Error fetching mentionable users:', err)
  }
}

const handleInput = (event) => {
  const cursorPosition = event.target.selectionStart
  const textBeforeCursor = newComment.value.slice(0, cursorPosition)
  const lastAtSymbol = textBeforeCursor.lastIndexOf('@')
  
  if (lastAtSymbol !== -1 && lastAtSymbol === textBeforeCursor.lastIndexOf('@')) {
    mentionQuery.value = textBeforeCursor.slice(lastAtSymbol + 1)
    showMentions.value = true
  } else {
    mentionQuery.value = ''
    showMentions.value = false
  }
}

const handleUserSelect = (user) => {
  const cursorPosition = newComment.value.lastIndexOf('@')
  const textBeforeMention = newComment.value.slice(0, cursorPosition)
  const textAfterMention = newComment.value.slice(cursorPosition + mentionQuery.value.length + 1)
  newComment.value = `${textBeforeMention}@${user.username} ${textAfterMention}`
  mentionQuery.value = ''
  showMentions.value = false
}

const handleFollowDeal = () => {
  if (!authStore.isAuthenticated) {
    openAuthModal()
    return
  }
  followDeal()
}

const followDeal = async () => {
  try {
    if (isFollowing.value) {
      await api.delete(`/deals/${props.deal._id}/follow`)
      props.deal.followCount--
    } else {
      await api.post(`/deals/${props.deal._id}/follow`)
      props.deal.followCount++
    }
    isFollowing.value = !isFollowing.value
    toast.success(isFollowing.value ? 'Deal followed successfully' : 'Deal unfollowed successfully')
  } catch (error) {
    console.error('Error following/unfollowing deal:', error)
    toast.error('An error occurred while following/unfollowing the deal')
  }
}

const handleAddComment = () => {
  if (!authStore.isAuthenticated) {
    openAuthModal()
    return
  }
  addComment()
}

const addComment = async () => {
  if (!newComment.value.trim()) return
  
  try {
    const response = await api.post(`/deals/${props.deal._id}/comments`, { content: newComment.value })
    const newCommentData = response.data.data.comment
    // Add the current user's information to the new comment
    newCommentData.user = {
      _id: authStore.user._id,
      username: authStore.user.username
    }
    comments.value.unshift(newCommentData)
    newComment.value = ''
    toast.success('Comment added successfully')
  } catch (err) {
    console.error('Error adding comment:', err)
    error.value = 'Failed to add comment. Please try again.'
    toast.error(error.value)
  }
}

const closeModal = () => {
  emit('close-modal')
}

const handleFollowUser = () => {
  if (!authStore.isAuthenticated) {
    openAuthModal()
    return
  }
  if (isCurrentUser.value) {
    toast.info("You can't follow yourself!")
    return
  }
  followUser()
}

const followUser = async () => {
  try {
    if (isFollowingUser.value) {
      await api.delete(`/users/${props.deal.user._id}/follow`)
    } else {
      await api.post(`/users/${props.deal.user._id}/follow`)
    }
    isFollowingUser.value = !isFollowingUser.value
    toast.success(isFollowingUser.value ? 'User followed successfully' : 'User unfollowed successfully')
  } catch (error) {
    console.error('Error following/unfollowing user:', error)
    if (error.response && error.response.data) {
      console.error('Error response:', error.response.data)
      toast.error(error.response.data.message || 'An error occurred while following/unfollowing the user')
    } else {
      toast.error('An error occurred while following/unfollowing the user')
    }
  }
}

const onImageLoad = (event) => {
  const img = event.target
  const aspectRatio = img.naturalWidth / img.naturalHeight
  let modalHeight

  if (aspectRatio > 1) {
    // Landscape image
    modalHeight = Math.min(window.innerHeight * 0.9, img.naturalHeight)
  } else {
    // Portrait image
    modalHeight = Math.min(window.innerHeight * 0.9, img.naturalHeight, 800)
  }

  modalStyle.value = {
    maxHeight: `${modalHeight}px`
  }

  if (imageContainer.value) {
    imageContainer.value.style.height = `${modalHeight}px`
  }
}

const openAuthModal = () => {
  emit('open-auth-modal')
}

onMounted(async () => {
  console.log('DealModal: Mounted')
  if (props.deal && props.deal._id) {
    await fetchDealData()
    await fetchMentionableUsers()
  }
})

watch(() => props.deal, async (newDeal, oldDeal) => {
  console.log('DealModal: Deal prop changed:', newDeal)
  if (newDeal && newDeal._id && (!oldDeal || newDeal._id !== oldDeal._id)) {
    try {
      await fetchDealData()
      await fetchMentionableUsers()
    } catch (err) {
      console.error('Error in watch effect:', err)
      error.value = 'An error occurred while loading deal data.'
      toast.error(error.value)
    }
  }
}, { immediate: true, deep: true }) // Added deep: true
</script>

<style scoped>
/* Styles remain the same */
</style>

================
File: components/FollowedDeals.vue
================
<!-- components/FollowedDeals.vue -->
<template>
    <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
      <div v-for="deal in followedDeals" :key="deal._id" class="flex items-center justify-between border-b border-gray-200 py-3">
        <div class="flex items-center">
          <img :src="getFullImageUrl(deal.imageUrl)" :alt="deal.title" class="w-16 h-16 object-cover mr-3 rounded-md">
          <div>
            <h4 class="font-medium">{{ deal.title }}</h4>
            <p class="text-sm text-gray-600">${{ deal.price }}</p>
          </div>
        </div>
        <button @click="$emit('unfollow', deal._id)" class="text-blue-600 hover:text-blue-800">Unfollow</button>
      </div>
    </div>
  </template>
  
  <script setup>
  import { useRuntimeConfig } from '#app'
  
  const props = defineProps(['followedDeals'])
  defineEmits(['unfollow'])
  
  const config = useRuntimeConfig()
  
  const getFullImageUrl = (imageUrl) => {
    if (!imageUrl) return ''
    return imageUrl.startsWith('http') 
      ? imageUrl 
      : `${config.public.apiBase}${imageUrl}`
  }
  </script>

================
File: components/Header.vue
================
<template>
  <header class="fixed top-0 left-0 right-0 bg-white bg-opacity-90 shadow-sm z-40 transition-all duration-300" :class="{ 'shadow-md': scrolled }">
    <div class="container mx-auto px-4 py-3 flex items-center justify-between">
      <div class="flex items-center">
        <NuxtLink to="/" class="text-xl font-bold mr-4 text-primary hover:text-blue-600 transition duration-300">
          Logo
        </NuxtLink>
        <input type="search" placeholder="Search deals..." class="bg-background rounded-md px-4 py-2 focus:outline-none focus:ring-2 focus:ring-primary transition duration-300">
      </div>
      <div class="flex items-center">
        <ClientOnly>
          <template v-if="!isAuthenticated">
            <button @click="openAuthModal('login')" class="btn btn-secondary mr-4">Log In</button>
            <button @click="openAuthModal('signup')" class="btn btn-primary">Sign Up</button>
          </template>
          <template v-else>
            <button @click="openPostDealModal" class="btn btn-secondary mr-4">Post a Deal</button>
            <NuxtLink to="/profile" class="text-text hover:text-primary mr-4 transition duration-300">
              <img v-if="profilePictureUrl" :src="profilePictureUrl" alt="Profile" class="w-8 h-8 rounded-full object-cover">
              <svg v-else xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M16 7a4 4 0 11-8 0 4 4 0 018 0zM12 14a7 7 0 00-7 7h14a7 7 0 00-7-7z" />
              </svg>
            </NuxtLink>
            <div class="relative">
              <button @click="toggleNotifications" class="text-text hover:text-primary mr-4 transition duration-300">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 17h5l-1.405-1.405A2.032 2.032 0 0118 14.158V11a6.002 6.002 0 00-4-5.659V5a2 2 0 10-4 0v.341C7.67 6.165 6 8.388 6 11v3.159c0 .538-.214 1.055-.595 1.436L4 17h5m6 0v1a3 3 0 11-6 0v-1m6 0H9" />
                </svg>
                <span v-if="unreadCount > 0" class="absolute -top-1 -right-1 bg-red-500 text-white rounded-full text-xs w-5 h-5 flex items-center justify-center">
                  {{ unreadCount }}
                </span>
              </button>
              <NotificationList v-if="showNotifications" @close="closeNotifications" />
            </div>
            <button @click="handleLogout" class="btn btn-accent">Logout</button>
          </template>
        </ClientOnly>
      </div>
    </div>
    <ClientOnly>
      <AuthModal v-if="showAuthModal" :is-login="isLoginMode" @close="closeAuthModal" @login="handleLogin" @signup="handleSignup" />
      <PostDealModal v-if="showPostDealModal" @close="closePostDealModal" @post-deal="handlePostDeal" />
    </ClientOnly>
  </header>
</template>

<script setup>
import { ref, computed, onMounted, onUnmounted, watch } from 'vue'
import { useAuthStore } from '~/stores/auth'
import { useNotificationStore } from '~/stores/notification'
import { useDealsStore } from '~/stores/deals' // {{ edit_1 }}
import { storeToRefs } from 'pinia'
import NotificationList from '~/components/NotificationList.vue'
import { useToast } from 'vue-toastification'

const authStore = useAuthStore()
const notificationStore = useNotificationStore()
const dealsStore = useDealsStore() // {{ edit_2 }}
const { isAuthenticated, user } = storeToRefs(authStore)
const { unreadCount } = storeToRefs(notificationStore)
const toast = useToast()

const showAuthModal = ref(false)
const showPostDealModal = ref(false)
const isLoginMode = ref(true)
const scrolled = ref(false)
const showNotifications = ref(false)

const handleScroll = () => {
  scrolled.value = window.scrollY > 0
}

onMounted(() => {
  window.addEventListener('scroll', handleScroll)
  if (isAuthenticated.value) {
    notificationStore.fetchNotifications()
  }
})

onUnmounted(() => {
  window.removeEventListener('scroll', handleScroll)
})

const handleLogout = () => {
  authStore.logout()
  notificationStore.clearNotifications()
}

const openAuthModal = (mode) => {
  isLoginMode.value = mode === 'login'
  showAuthModal.value = true
}

const closeAuthModal = () => {
  showAuthModal.value = false
}

const openPostDealModal = () => {
  showPostDealModal.value = true
}

const closePostDealModal = () => {
  showPostDealModal.value = false
}

const handlePostDeal = async (dealData) => { // {{ edit_3 }}
  try {
    await dealsStore.postDeal(dealData)
    closePostDealModal()
    toast.success('Deal posted successfully!')
  } catch (error) {
    console.error('Error posting deal:', error)
    toast.error('Failed to post deal. Please try again.')
  }
}

const handleLogin = async (credentials) => {
  try {
    const success = await authStore.login(credentials.email, credentials.password)
    if (success) {
      await notificationStore.fetchNotifications()
      closeAuthModal()
      toast.success('Successfully logged in!')
    } else {
      toast.error('Login failed. Please check your credentials and try again.')
    }
  } catch (error) {
    console.error('Login error:', error)
    toast.error(error.response?.data?.message || 'An error occurred during login')
  }
}

const handleSignup = async (userData) => {
  try {
    const success = await authStore.signup(userData)
    if (success) {
      await notificationStore.fetchNotifications()
      closeAuthModal()
      toast.success('Successfully signed up!')
    } else {
      toast.error('Signup failed. Please check your information and try again.')
    }
  } catch (error) {
    console.error('Signup error:', error)
    toast.error(error.response?.data?.message || 'An error occurred during signup')
  }
}

const toggleNotifications = () => {
  showNotifications.value = !showNotifications.value
  if (showNotifications.value) {
    notificationStore.fetchNotifications()
  }
}

const closeNotifications = () => {
  showNotifications.value = false
}

const profilePictureUrl = computed(() => {
  if (user.value?.profilePicture) {
    return user.value.profilePicture.startsWith('http')
      ? user.value.profilePicture
      : `http://localhost:5000${user.value.profilePicture}`
  }
  return null
})

watch(() => isAuthenticated.value, (newValue) => {
  if (newValue) {
    notificationStore.fetchNotifications()
  } else {
    notificationStore.clearNotifications()
  }
})
</script>

================
File: components/NotificationList.vue
================
<template>
    <div class="absolute right-0 mt-2 w-80 bg-white rounded-md shadow-lg overflow-hidden z-20">
      <div class="py-2">
        <h3 class="text-lg leading-6 font-medium text-gray-900 px-4 py-2">Notifications</h3>
        <div v-if="sortedNotifications.length === 0" class="px-4 py-2 text-sm text-gray-500">
          No notifications
        </div>
        <ul v-else class="divide-y divide-gray-200">
          <li v-for="notification in sortedNotifications" :key="notification._id" class="px-4 py-3 hover:bg-gray-50">
            <div class="flex items-center">
              <div class="flex-shrink-0">
                <span class="inline-block h-2 w-2 rounded-full" :class="notification.read ? 'bg-gray-300' : 'bg-blue-500'"></span>
              </div>
              <div class="ml-3 w-0 flex-1">
                <p class="text-sm font-medium text-gray-900" :class="{ 'font-bold': !notification.read }">
                  <template v-if="notification.type === 'MENTION'">
                    You were mentioned in a comment on 
                    <NuxtLink :to="`/deals/${notification.relatedDeal._id}`" class="text-blue-600 hover:underline">
                      {{ notification.relatedDeal.title }}
                    </NuxtLink>
                  </template>
                  <template v-else>
                    {{ notification.content }}
                  </template>
                </p>
                <p class="text-sm text-gray-500">
                  {{ formatDate(notification.createdAt) }}
                </p>
              </div>
              <div class="ml-4 flex-shrink-0">
                <button @click="markAsRead(notification._id)" class="text-sm font-medium text-indigo-600 hover:text-indigo-500">
                  Mark as read
                </button>
              </div>
            </div>
          </li>
        </ul>
      </div>
      <div class="bg-gray-50 px-4 py-3 sm:px-6">
        <NuxtLink to="/notifications" class="text-sm font-medium text-indigo-600 hover:text-indigo-500">
          View all notifications
        </NuxtLink>
      </div>
    </div>
  </template>
  
  <script setup>
  import { computed } from 'vue'
  import { useNotificationStore } from '~/stores/notification'
  import { storeToRefs } from 'pinia'
  
  const notificationStore = useNotificationStore()
  const { notifications } = storeToRefs(notificationStore)
  
  const sortedNotifications = computed(() => {
    console.log('Current notifications:', notifications.value)
    return notifications.value.slice(0, 5)
  })
    
  const markAsRead = (notificationId) => {
    notificationStore.markNotificationAsRead(notificationId)
  }
  
  const formatDate = (date) => {
    return new Date(date).toLocaleString()
  }
  
  console.log('All notifications:', notifications.value);
  const mentionNotifications = computed(() => 
    notifications.value.filter(n => n.type === 'MENTION')
  );
  console.log('Mention notifications:', mentionNotifications.value);
  
  defineEmits(['close'])
  </script>

================
File: components/PostDealModal.vue
================
<template>
  <div class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
    <div class="bg-white rounded-lg w-full max-w-2xl p-8 relative">
      <button @click="$emit('close')" class="absolute top-4 right-4 text-gray-500 hover:text-gray-700">
        <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12" />
        </svg>
      </button>
      
      <h2 class="text-3xl font-bold mb-6 text-center text-blue-600">
        {{ step === 1 ? 'Post a New Deal' : 'Complete Deal Details' }}
      </h2>

      <!-- Step 1: Enter deal link -->
      <div v-if="step === 1">
        <p class="text-center text-gray-600 mb-6">
          Enter the link to the deal you want to share
        </p>
        <form @submit.prevent="fetchDealInfo">
          <div class="mb-4">
            <label for="dealLink" class="block text-gray-700 text-sm font-bold mb-2">Deal Link</label>
            <input type="url" id="dealLink" v-model="dealLink" class="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500" required>
          </div>
          <button type="submit" class="w-full bg-blue-600 text-white py-2 px-4 rounded-md hover:bg-blue-700 transition duration-300">
            Next
          </button>
        </form>
      </div>

      <!-- Step 2: Complete deal details -->
      <div v-else>
        <div class="mb-6">
          <div class="w-full h-64 flex items-center justify-center mb-2 overflow-hidden">
            <img v-if="dealImage" :src="dealImage" alt="Deal Image" class="max-w-full max-h-full object-contain">
            <span v-else class="text-gray-500">No image available</span>
          </div>
          <div class="flex justify-between">
            <button @click="triggerFileInput" class="text-blue-600 hover:text-blue-800">
              {{ dealImage ? 'Replace Image' : 'Upload Image' }}
            </button>
            <button v-if="dealImage" @click="removeImage" class="text-red-600 hover:text-red-800">
              Remove Image
            </button>
          </div>
          <input type="file" ref="fileInput" @change="handleFileChange" class="hidden" accept="image/*">
        </div>

        <form @submit.prevent="submitDeal">
          <div class="mb-4">
            <label for="title" class="block text-gray-700 text-sm font-bold mb-2">Deal Title</label>
            <input type="text" id="title" v-model="dealDetails.title" class="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500" required>
          </div>
          
          <div class="mb-4">
            <label for="description" class="block text-gray-700 text-sm font-bold mb-2">Description</label>
            <textarea id="description" v-model="dealDetails.description" rows="3" class="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500" required></textarea>
          </div>
          
          <div class="mb-4">
            <label for="price" class="block text-gray-700 text-sm font-bold mb-2">Price ($)</label>
            <input type="number" id="price" v-model="dealDetails.price" step="0.01" min="0" class="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500" required>
          </div>
          
          <div class="mb-6">
            <label for="category" class="block text-gray-700 text-sm font-bold mb-2">Category</label>
            <select id="category" v-model="dealDetails.category" class="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500" required>
              <option value="">Select a category</option>
              <option value="electronics">Electronics</option>
              <option value="fashion">Fashion</option>
              <option value="home">Home & Garden</option>
              <option value="toys">Toys & Games</option>
              <option value="other">Other</option>
            </select>
          </div>
          
          <button type="submit" class="w-full bg-blue-600 text-white py-2 px-4 rounded-md hover:bg-blue-700 transition duration-300">
            Post Deal
          </button>
        </form>
      </div>
    </div>
  </div>
</template>

<script setup>
import { ref, reactive } from 'vue'
import api from '~/services/api'
import { useToast } from "vue-toastification"
import { useDealsStore } from '~/stores/deals'

const emit = defineEmits(['close'])

const step = ref(1)
const dealLink = ref('')
const dealImage = ref('')
const fileInput = ref(null)

const dealDetails = reactive({
  title: '',
  description: '',
  price: '',
  category: ''
})

const toast = useToast()
const dealsStore = useDealsStore()

const fetchDealInfo = async () => {
  try {
    const response = await api.post('/deals/fetch-image', { url: dealLink.value })
    dealImage.value = `http://localhost:5000${response.data.data.imageUrl}`
  } catch (error) {
    console.error('Error fetching deal image:', error)
    toast.error('Failed to fetch deal image. You can upload an image manually.')
  } finally {
    step.value = 2 // Always proceed to step 2, even if image fetching fails
  }
}

const triggerFileInput = () => {
  fileInput.value.click()
}

const handleFileChange = async (event) => {
  const file = event.target.files[0]
  if (file) {
    const formData = new FormData()
    formData.append('image', file)
    try {
      const response = await api.post('/deals/upload-image', formData, {
        headers: {
          'Content-Type': 'multipart/form-data'
        }
      })
      dealImage.value = `http://localhost:5000${response.data.data.imageUrl}`
      toast.success('Image uploaded successfully')
    } catch (error) {
      console.error('Error uploading image:', error)
      toast.error('Failed to upload image. Please try again.')
    }
  }
}

const removeImage = () => {
  dealImage.value = ''
  toast.info('Image removed')
}

const submitDeal = async () => {
  try {
    const dealData = {
      ...dealDetails,
      price: parseFloat(dealDetails.price).toFixed(2),
      imageUrl: dealImage.value,
      link: dealLink.value
    }
    const response = await api.post('/deals', dealData)
    const newDeal = response.data.data.deal
    console.log('New deal from API:', newDeal)
    dealsStore.handleNewDeal(newDeal)
    emit('close')
    toast.success('Deal posted successfully!')
  } catch (error) {
    console.error('Error submitting deal:', error)
    toast.error('Failed to submit deal. Please try again.')
  }
}
</script>

<style scoped>
.max-w-full {
  max-width: 100%;
}
.max-h-full {
  max-height: 100%;
}
</style>

================
File: components/UserAvatar.vue
================
<!-- components/UserAvatar.vue -->
<template>
  <div :class="avatarClasses" :style="avatarStyle">
    <span v-if="!imageLoaded">{{ initials }}</span>
    <img v-if="src" :src="src" @load="onImageLoad" @error="onImageError" class="w-full h-full object-cover" :alt="name">
  </div>
</template>

<script setup>
import { ref, computed } from 'vue';

const props = defineProps({
  name: {
    type: String,
    required: true
  },
  size: {
    type: Number,
    default: 40
  },
  src: {
    type: String,
    default: ''
  }
});

const imageLoaded = ref(false);

const initials = computed(() => {
  return props.name
    .split(' ')
    .map(word => word[0])
    .join('')
    .toUpperCase()
    .slice(0, 2);
});

const avatarClasses = computed(() => {
  return [
    'flex items-center justify-center rounded-full overflow-hidden bg-gray-300 text-gray-600',
    `w-${props.size / 4} h-${props.size / 4}`
  ];
});

const avatarStyle = computed(() => {
  return {
    width: `${props.size}px`,
    height: `${props.size}px`,
    fontSize: `${props.size / 2.5}px`
  };
});

const onImageLoad = () => {
  imageLoaded.value = true;
};

const onImageError = () => {
  imageLoaded.value = false;
};
</script>

================
File: components/UserDeals.vue
================
<!-- components/UserDeals.vue -->
<template>
    <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
      <div v-for="deal in userDeals" :key="deal._id" class="flex items-center justify-between border-b border-gray-200 py-3">
        <div class="flex items-center">
          <img :src="getFullImageUrl(deal.imageUrl)" :alt="deal.title" class="w-16 h-16 object-cover mr-3 rounded-md">
          <div>
            <h4 class="font-medium">{{ deal.title }}</h4>
            <p class="text-sm text-gray-600">${{ deal.price }}</p>
          </div>
        </div>
        <span class="text-gray-600">{{ deal.upvotes }} upvotes</span>
      </div>
    </div>
  </template>
  
  <script setup>
  import { useRuntimeConfig } from '#app'
  
  const props = defineProps(['userDeals'])
  
  const config = useRuntimeConfig()
  
  const getFullImageUrl = (imageUrl) => {
    if (!imageUrl) return ''
    return imageUrl.startsWith('http') 
      ? imageUrl 
      : `${config.public.apiBase}${imageUrl}`
  }
  </script>

================
File: components/UserMentionAutocomplete.vue
================
<template>
    <div class="absolute z-10 bg-white border border-gray-300 rounded-md shadow-lg max-h-40 overflow-y-auto">
      <ul>
        <li
          v-for="user in filteredUsers"
          :key="user._id"
          @click="selectUser(user)"
          class="px-4 py-2 hover:bg-gray-100 cursor-pointer"
        >
          {{ user.username }}
        </li>
      </ul>
    </div>
  </template>
  
  <script setup>
  import { computed } from 'vue';
  
  const props = defineProps({
    users: Array,
    query: String,
  });
  
  const emit = defineEmits(['select']);
  
  const filteredUsers = computed(() => {
    if (!props.query) return props.users;
    return props.users.filter(user => 
      user.username.toLowerCase().includes(props.query.toLowerCase())
    );
  });
  
  const selectUser = (user) => {
    emit('select', user);
  };
  </script>

================
File: composables/useProfile.ts
================
import { useState } from '#app'

export const useProfile = () => useState('profile', () => ({
  showProfile: false
}))

export const useProfileActions = () => {
  const profile = useProfile()

  const openProfile = () => {
    profile.value.showProfile = true
  }

  const closeProfile = () => {
    profile.value.showProfile = false
  }

  return { openProfile, closeProfile }
}

================
File: composables/useSocket.js
================
import { ref, onMounted, onUnmounted } from 'vue'
import { useNuxtApp } from '#app'

export const useSocket = () => {
  const nuxtApp = useNuxtApp()
  const socket = ref(null)
  const isConnected = ref(false)
  const lastMessage = ref(null)
  const connectionError = ref(null)

  const initSocket = () => {
    console.log('Initializing socket...')
    socket.value = nuxtApp.$socket
    if (socket.value) {
      console.log('Socket instance found:', socket.value.id)

      socket.value.on('connect', () => {
        console.log('Socket connected:', socket.value.id)
        isConnected.value = true
        connectionError.value = null
      })

      socket.value.on('connect_error', (error) => {
        console.error('Socket connection error:', error.message)
        isConnected.value = false
        connectionError.value = error.message
      })

      socket.value.on('disconnect', (reason) => {
        console.log('Socket disconnected:', reason)
        isConnected.value = false
      })

      socket.value.on('testResponse', (data) => {
        console.log('Received test response:', data)
        lastMessage.value = data.message
      })
    } else {
      console.error('Socket instance not found')
      connectionError.value = 'Socket instance not found'
    }
  }

  const testConnection = () => {
    if (socket.value && socket.value.connected) {
      console.log('Emitting test event...')
      socket.value.emit('testConnection', { test: 'data' })
    } else {
      console.error('Socket not connected', socket.value)
      connectionError.value = 'Socket not connected'
    }
  }

  onMounted(() => {
    initSocket()
  })

  onUnmounted(() => {
    if (socket.value) {
      console.log('Cleaning up socket listeners')
      socket.value.off('connect')
      socket.value.off('connect_error')
      socket.value.off('disconnect')
      socket.value.off('testResponse')
    }
  })

  return {
    isConnected,
    lastMessage,
    connectionError,
    testConnection
  }
}

================
File: layouts/default.vue
================
<template>
  <div>
    <Header />
    <main class="pt-16"> <!-- Add padding-top to account for fixed header -->
      <slot />
    </main>
  </div>
</template>

<script setup>
import Header from '~/components/Header.vue'
</script>

================
File: nuxt.config.ts
================
// https://nuxt.com/docs/api/configuration/nuxt-config
export default defineNuxtConfig({
  devtools: { enabled: true },
  modules: [
    '@nuxtjs/tailwindcss',
    '@pinia/nuxt'
  ],
  css: [
    '@/assets/css/tailwind.css',
    'vue-toastification/dist/index.css',
    '@fortawesome/fontawesome-svg-core/styles.css'
  ],

  runtimeConfig: {
    public: {
      apiBase: 'http://localhost:5000/api/v1', // Your backend API URL
      socketUrl: process.env.SOCKET_URL || 'http://localhost:5000'
    }
  },

  compatibilityDate: '2024-09-22',
  plugins: [
    '~/plugins/userAvatar.js',
    '~/plugins/toast.js',
    '~/plugins/fontawesome.js',
    '~/plugins/auth.js',
    '~/plugins/socket.js',
  ],
  ssr: true
})

================
File: package.json
================
{
  "name": "nuxt-app",
  "private": true,
  "type": "module",
  "scripts": {
    "build": "nuxt build",
    "dev": "nuxt dev",
    "generate": "nuxt generate",
    "preview": "nuxt preview",
    "postinstall": "nuxt prepare"
  },
  "dependencies": {
    "@fortawesome/fontawesome-svg-core": "^6.6.0",
    "@fortawesome/free-solid-svg-icons": "^6.6.0",
    "@fortawesome/vue-fontawesome": "^3.0.0-5",
    "@pinia/nuxt": "^0.5.1",
    "axios": "^1.7.7",
    "date-fns": "^4.1.0",
    "nuxt": "^3.13.2",
    "pinia": "^2.1.7",
    "socket.io-client": "^4.8.0",
    "vue": "^3.3.4",
    "vue-router": "latest",
    "vue-toastification": "^2.0.0-rc.5"
  },
  "devDependencies": {
    "@nuxtjs/tailwindcss": "^6.12.1",
    "nuxt-icon": "^1.0.0-beta.7"
  }
}

================
File: pages/index.vue
================
<template>
  <div>
    <div v-if="loading" class="text-center py-8">Loading deals...</div>
    <div v-else-if="error" class="text-center py-8 text-red-500">{{ error }}</div>
    <div v-else class="container mx-auto px-4 py-8">
      <div class="grid grid-cols-1 sm:grid-cols-2 md:grid-cols-3 lg:grid-cols-4 gap-6">
        <DealCard 
          v-for="deal in safeDeals" 
          :key="deal._id" 
          :deal="deal" 
          @open-modal="openModal" 
        />
      </div>
    </div>
    <DealModal 
      v-if="selectedDeal" 
      :deal="selectedDeal" 
      @close-modal="closeModal" 
      @open-auth-modal="openAuthModal" 
    />
    <AuthModal v-if="showAuthModal" @close="closeAuthModal" />

    <!-- Socket Connection Test Section -->
    <div class="container mx-auto px-4 py-8 mt-8 bg-gray-100 rounded-lg">
      <h2 class="text-2xl font-bold mb-4">Socket Connection Test</h2>
      <p>Connection status: {{ isConnected ? 'Connected' : 'Disconnected' }}</p>
      <button 
        @click="testConnection" 
        class="mt-2 px-4 py-2 bg-blue-500 text-white rounded hover:bg-blue-600"
      >
        Test Socket Connection
      </button>
      <p v-if="lastMessage" class="mt-2">Last message: {{ lastMessage }}</p>
      <p v-if="connectionError" class="mt-2 text-red-500">Error: {{ connectionError }}</p>
    </div>
  </div>
</template>

<script setup>
import { useDealsStore } from '~/stores/deals'
import { storeToRefs } from 'pinia'
import { onMounted, ref, computed, onUnmounted, watch } from 'vue'
import DealCard from '~/components/DealCard.vue'
import DealModal from '~/components/DealModal.vue'
import AuthModal from '~/components/AuthModal.vue'
import { useSocket } from '~/composables/useSocket'
import { useToast } from 'vue-toastification'

const dealsStore = useDealsStore()
const { deals, loading, error } = storeToRefs(dealsStore)
const toast = useToast()

const { $socket } = useNuxtApp()

onMounted(async () => {
  // Fetch deals only if the store is empty
  if (deals.value.length === 0) {
    await dealsStore.fetchDeals()
  }

  $socket.on('newDeal', (data) => {
    console.log('Received new deal:', data)
    dealsStore.handleNewDeal(data.deal)
    toast.success(`New deal added: ${data.deal.title}`)
  })

  $socket.on('updateDeal', (data) => {
    console.log('Received deal update:', data)
    dealsStore.handleNewDeal(data.deal) // We can use the same method for updates
    toast.info(`Deal updated: ${data.deal.title}`)
  })
})

onUnmounted(() => {
  $socket.off('newDeal')
  $socket.off('updateDeal')
})

const selectedDeal = ref(null)
const showAuthModal = ref(false)

const openModal = (deal) => {
  selectedDeal.value = dealsStore.getDealById(deal._id) // Updated to fetch deal by ID
}

const closeModal = () => {
  selectedDeal.value = null
}

const openAuthModal = () => {
  showAuthModal.value = true
}

const closeAuthModal = () => {
  showAuthModal.value = false
}

// Socket connection test
const { isConnected, lastMessage, connectionError, testConnection } = useSocket()

// Computed property to ensure deals is always an array and sorted
const safeDeals = computed(() => {
  console.log('Computing safeDeals:', dealsStore.getSortedDeals) // Added console log for debugging
  return dealsStore.getSortedDeals
})

// Watch for changes in the deals store
watch(() => dealsStore.deals, (newDeals) => {
  console.log('Deals updated:', newDeals)
}, { deep: true })
</script>

================
File: pages/notifications.vue
================
<template>
    <div class="container mx-auto px-4 py-8 pt-24">
      <div v-if="loading" class="text-center py-8">Loading notifications...</div>
      <div v-else class="bg-white shadow-lg rounded-lg overflow-hidden">
        <div class="p-6">
          <h2 class="text-2xl font-semibold mb-6">Notifications</h2>
          
          <div v-if="notifications.length === 0" class="text-center text-gray-500">
            No notifications to display.
          </div>
          
          <ul v-else class="divide-y divide-gray-200">
            <li v-for="notification in notifications" :key="notification._id" class="py-4">
              <div class="flex items-center">
                <div class="flex-shrink-0">
                  <span class="inline-block h-2 w-2 rounded-full" :class="notification.read ? 'bg-gray-300' : 'bg-blue-500'"></span>
                </div>
                <div class="ml-3 w-0 flex-1">
                  <p class="text-sm font-medium text-gray-900" :class="{ 'font-bold': !notification.read }">
                    {{ notification.content }}
                  </p>
                  <p class="text-sm text-gray-500">
                    {{ formatDate(notification.createdAt) }}
                  </p>
                </div>
                <div class="ml-4 flex-shrink-0">
                  <button @click="markAsRead(notification._id)" v-if="!notification.read" class="text-sm font-medium text-indigo-600 hover:text-indigo-500">
                    Mark as read
                  </button>
                </div>
              </div>
            </li>
          </ul>
          
          <div v-if="notifications.length > 0" class="mt-6 flex justify-end">
            <button @click="markAllAsRead" class="bg-blue-600 text-white px-4 py-2 rounded-md hover:bg-blue-700 transition duration-300">
              Mark all as read
            </button>
          </div>
        </div>
      </div>
    </div>
  </template>
  
  <script setup>
  import { ref, onMounted } from 'vue'
  import { useNotificationStore } from '~/stores/notification'
  import { storeToRefs } from 'pinia'
  
  const notificationStore = useNotificationStore()
  const { notifications } = storeToRefs(notificationStore)
  const loading = ref(true)
  
  onMounted(async () => {
    await notificationStore.fetchNotifications()
    loading.value = false
  })
  
  const markAsRead = async (notificationId) => {
    await notificationStore.markNotificationAsRead(notificationId)
  }
  
  const markAllAsRead = async () => {
    await notificationStore.markAllNotificationsAsRead()
  }
  
  const formatDate = (date) => {
    return new Date(date).toLocaleString()
  }
  </script>

================
File: pages/profile.vue
================
<template>
  <div class="container mx-auto px-4 py-8 pt-24">
    <div v-if="loading" class="text-center py-8">Loading user data...</div>
    <div v-else-if="error" class="text-center py-8 text-red-500">{{ error }}</div>
    <div v-else-if="!user" class="text-center py-8 text-red-500">User data not available. Please try logging in again.</div>
    <div v-else class="bg-white shadow-lg rounded-lg overflow-hidden">
      <div class="p-6">
        <div class="flex items-center mb-6">
          <div class="relative">
            <UserAvatar 
              :name="getUserName" 
              :size="80" 
              :src="fullProfilePictureUrl" 
              class="mr-6" 
            />
            <button @click="triggerFileInput" class="absolute bottom-0 right-6 bg-blue-500 text-white rounded-full p-2 hover:bg-blue-600">
              <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M3 9a2 2 0 012-2h.93a2 2 0 001.664-.89l.812-1.22A2 2 0 0110.07 4h3.86a2 2 0 011.664.89l.812 1.22A2 2 0 0018.07 7H19a2 2 0 012 2v9a2 2 0 01-2 2H5a2 2 0 01-2-2V9z" />
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 13a3 3 0 11-6 0 3 3 0 016 0z" />
              </svg>
            </button>
            <input type="file" ref="fileInput" @change="handleFileChange" class="hidden" accept="image/*">
          </div>
          <div>
            <h3 class="text-xl font-semibold">{{ getUserName }}</h3>
            <p class="text-gray-600">{{ user.email }}</p>
          </div>
        </div>

        <!-- Tabs -->
        <div class="border-b border-gray-200 mb-6">
          <nav class="flex">
            <button v-for="tab in tabs" :key="tab.id" @click="currentTab = tab.id" 
                    :class="['mr-8 py-2 px-1 border-b-2 font-medium text-sm', 
                             currentTab === tab.id ? 'border-blue-500 text-blue-600' : 'border-transparent text-gray-500 hover:text-gray-700 hover:border-gray-300']">
              {{ tab.name }}
            </button>
          </nav>
        </div>

        <!-- Tab content -->
        <div v-if="currentTab === 'info'" class="grid grid-cols-2 gap-4">
          <div v-for="field in userFields" :key="field.key" class="flex flex-col">
            <label :for="field.key" class="text-sm font-medium text-gray-700 mb-1">{{ field.label }}</label>
            <input :id="field.key" v-model="user[field.key]" :type="field.type" class="border border-gray-300 rounded-md px-3 py-2 focus:outline-none focus:ring-2 focus:ring-blue-500">
          </div>
          <div class="col-span-2">
            <button @click="saveChanges" class="bg-blue-600 text-white px-4 py-2 rounded-md hover:bg-blue-700 transition duration-300">Save Changes</button>
          </div>
        </div>

        <div v-else-if="currentTab === 'password'" class="grid grid-cols-2 gap-4">
          <div v-for="field in passwordFields" :key="field.key" class="flex flex-col">
            <label :for="field.key" class="text-sm font-medium text-gray-700 mb-1">{{ field.label }}</label>
            <input :id="field.key" v-model="passwordChange[field.key]" type="password" class="border border-gray-300 rounded-md px-3 py-2 focus:outline-none focus:ring-2 focus:ring-blue-500">
          </div>
          <div class="col-span-2">
            <button @click="changePassword" class="bg-blue-600 text-white px-4 py-2 rounded-md hover:bg-blue-700 transition duration-300">Change Password</button>
          </div>
        </div>

        <div v-else-if="currentTab === 'following'" class="grid grid-cols-1 md:grid-cols-2 gap-4">
          <div v-for="followedUser in followingUsers" :key="followedUser._id" class="flex items-center justify-between border-b border-gray-200 py-3">
            <div class="flex items-center">
              <UserAvatar 
                :name="followedUser.firstName && followedUser.lastName ? `${followedUser.firstName} ${followedUser.lastName}` : followedUser.username || ''" 
                :size="40" 
                :src="getFullProfilePictureUrl(followedUser.profilePicture)" 
                class="mr-3" 
              />
              <span class="font-medium">{{ followedUser.username }}</span>
            </div>
            <button @click="unfollowUser(followedUser._id)" class="text-blue-600 hover:text-blue-800">Unfollow</button>
          </div>
        </div>

        <div v-else-if="currentTab === 'followers'" class="grid grid-cols-1 md:grid-cols-2 gap-4">
          <div v-for="follower in followers" :key="follower._id" class="flex items-center justify-between border-b border-gray-200 py-3">
            <div class="flex items-center">
              <UserAvatar 
                :name="follower.firstName && follower.lastName ? `${follower.firstName} ${follower.lastName}` : follower.username || ''" 
                :size="40" 
                :src="getFullProfilePictureUrl(follower.profilePicture)" 
                class="mr-3" 
              />
              <span class="font-medium">{{ follower.username }}</span>
            </div>
            <button v-if="!isFollowing(follower._id)" @click="followUser(follower._id)" class="text-blue-600 hover:text-blue-800">Follow Back</button>
            <span v-else class="text-gray-500">Following</span>
          </div>
        </div>

        <div v-else-if="currentTab === 'deals'">
          <UserDeals :userDeals="userDeals" />
        </div>

        <div v-else-if="currentTab === 'followedDeals'">
          <FollowedDeals :followedDeals="followedDeals" @unfollow="unfollowDeal" />
        </div>
      </div>
    </div>
  </div>
</template>

<script setup>
import { ref, onMounted, watch, computed } from 'vue'
import { useRuntimeConfig } from '#app'
import api from '~/services/api'
import FollowedDeals from '~/components/FollowedDeals.vue'
import UserDeals from '~/components/UserDeals.vue'
import UserAvatar from '~/components/UserAvatar.vue'
import { useAuthStore } from '~/stores/auth'
import { useDealsStore } from '~/stores/deals'
import { storeToRefs } from 'pinia'

const config = useRuntimeConfig()
const fileInput = ref(null)
const loading = ref(true)
const error = ref(null)

const currentTab = ref('info')
const tabs = [
  { id: 'info', name: 'Personal Info' },
  { id: 'password', name: 'Change Password' },
  { id: 'following', name: 'Following' },
  { id: 'followers', name: 'Followers' },
  { id: 'deals', name: 'My Deals' },
  { id: 'followedDeals', name: 'Followed Deals' }
]

const authStore = useAuthStore()
const dealsStore = useDealsStore()

const { user } = storeToRefs(authStore)
const userDeals = ref([])
const followedDeals = ref([])

const followingUsers = ref([])
const followers = ref([])

onMounted(async () => {
  try {
    if (!user.value) {
      await authStore.fetchUser()
    }
    await Promise.all([
      fetchUserDeals(),
      fetchFollowedDeals(),
      fetchFollowing(),
      fetchFollowers()
    ])
  } catch (err) {
    console.error('Error loading user data:', err)
    error.value = 'Error loading user data. Please try again.'
  } finally {
    loading.value = false
  }
})

const getUserName = computed(() => {
  if (!user.value) return ''
  return user.value.firstName && user.value.lastName
    ? `${user.value.firstName} ${user.value.lastName}`
    : user.value.username || ''
})

const fullProfilePictureUrl = computed(() => {
  if (!user.value || !user.value.profilePicture) return ''
  return user.value.profilePicture.startsWith('http') 
    ? user.value.profilePicture 
    : `${config.public.apiBase}${user.value.profilePicture}`
})

const getFullProfilePictureUrl = (profilePicture) => {
  if (!profilePicture) return ''
  return profilePicture.startsWith('http') 
    ? profilePicture 
    : `${config.public.apiBase}${profilePicture}`
}

const fetchFollowedDeals = async () => {
  try {
    const response = await api.get('/deals/followed')
    followedDeals.value = response.data.data.followedDeals
  } catch (error) {
    console.error('Error fetching followed deals:', error)
    throw error
  }
}

const fetchUserDeals = async () => {
  try {
    const response = await api.get('/users/me/deals')
    userDeals.value = response.data.data.deals
  } catch (error) {
    console.error('Error fetching user deals:', error)
    throw error
  }
}

const fetchFollowing = async () => {
  try {
    const response = await api.get('/users/me/following')
    followingUsers.value = response.data.data.following
  } catch (error) {
    console.error('Error fetching following users:', error)
    throw error
  }
}

const fetchFollowers = async () => {
  try {
    const response = await api.get('/users/me/followers')
    followers.value = response.data.data.followers
  } catch (error) {
    console.error('Error fetching followers:', error)
    throw error
  }
}

const unfollowUser = async (userId) => {
  try {
    await api.delete(`/users/${userId}/follow`)
    followingUsers.value = followingUsers.value.filter(user => user._id !== userId)
  } catch (error) {
    console.error('Error unfollowing user:', error)
  }
}

const followUser = async (userId) => {
  try {
    await api.post(`/users/${userId}/follow`)
    await fetchFollowers()
  } catch (error) {
    console.error('Error following user:', error)
  }
}

const unfollowDeal = async (dealId) => {
  try {
    await api.delete(`/deals/${dealId}/follow`)
    followedDeals.value = followedDeals.value.filter(deal => deal._id !== dealId)
  } catch (error) {
    console.error('Error unfollowing deal:', error)
  }
}

const isFollowing = (userId) => {
  return followingUsers.value.some(user => user._id === userId)
}

const handleFileChange = async (event) => {
  const file = event.target.files[0]
  if (file) {
    const formData = new FormData()
    formData.append('image', file)
    try {
      const response = await api.post('/users/upload-profile-picture', formData)
      user.value.profilePicture = response.data.data.user.profilePicture
    } catch (error) {
      console.error('Error uploading profile picture:', error)
    }
  }
}

const triggerFileInput = () => {
  fileInput.value.click()
}

watch(currentTab, async (newTab) => {
  if (newTab === 'following') {
    await fetchFollowing()
  } else if (newTab === 'followedDeals') {
    await fetchFollowedDeals()
  } else if (newTab === 'followers') {
    await fetchFollowers()
  } else if (newTab === 'deals') {
    await fetchUserDeals()
  }
})

const userFields = [
  { key: 'firstName', label: 'First Name', type: 'text' },
  { key: 'lastName', label: 'Last Name', type: 'text' },
  { key: 'email', label: 'Email', type: 'email' }
]

const passwordChange = ref({
  currentPassword: '',
  newPassword: '',
  confirmPassword: ''
})

const passwordFields = [
  { key: 'currentPassword', label: 'Current Password' },
  { key: 'newPassword', label: 'New Password' },
  { key: 'confirmPassword', label: 'Confirm New Password' }
]

const saveChanges = async () => {
  try {
    const response = await api.put('/users/me', user.value)
    user.value = response.data.data.user
    // Show success message
    console.log('User data updated successfully')
  } catch (error) {
    console.error('Error updating user data:', error)
    // Show error message
  }
}

const changePassword = async () => {
  try {
    await api.post('/users/change-password', passwordChange.value)
    // Show success message
    console.log('Password changed successfully')
    // Clear the form fields
    passwordChange.value = { currentPassword: '', newPassword: '', confirmPassword: '' }
  } catch (error) {
    console.error('Error changing password:', error)
    // Show error message
  }
}
</script>

================
File: plugins/auth-check.js
================
// plugins/auth-check.js
export default defineNuxtPlugin(async (nuxtApp) => {
    const authStore = useAuthStore()
    const { $cookies } = useNuxtApp()
  
    // Use useCookie instead of localStorage
    const token = useCookie('auth_token')
  
    if (process.client && token.value) {
      try {
        await authStore.fetchUser()
      } catch (error) {
        console.error('Error fetching user data:', error)
        // Handle the error (e.g., redirect to login page)
      }
    }
  })

================
File: plugins/auth.js
================
import { useAuthStore } from '~/stores/auth'

export default defineNuxtPlugin(async (nuxtApp) => {
  const authStore = useAuthStore()
  
  // Only run initializeAuth on client-side
  if (process.client) {
    await authStore.initializeAuth()
  }
})

================
File: plugins/fontawesome.js
================
import { library, config } from '@fortawesome/fontawesome-svg-core'
import { FontAwesomeIcon } from '@fortawesome/vue-fontawesome'

// This is important, we are going to let Nuxt worry about the CSS
config.autoAddCss = false

// Dynamic imports for Font Awesome icons
export default defineNuxtPlugin(async (nuxtApp) => {
  const icons = await Promise.all([
    import('@fortawesome/free-solid-svg-icons/faArrowUp'),
    import('@fortawesome/free-solid-svg-icons/faArrowDown'),
    import('@fortawesome/free-solid-svg-icons/faChevronUp'),
    import('@fortawesome/free-solid-svg-icons/faChevronDown')
  ])

  icons.forEach(icon => library.add(icon.definition))

  nuxtApp.vueApp.component('font-awesome-icon', FontAwesomeIcon)
})

================
File: plugins/socket.js
================
import io from 'socket.io-client'
import { useAuthStore } from '~/stores/auth'
import { useNotificationStore } from '~/stores/notification'
import { useDealsStore } from '~/stores/deals'

export default defineNuxtPlugin((nuxtApp) => {
  const config = useRuntimeConfig()
  const authStore = useAuthStore()
  const notificationStore = useNotificationStore()
  const dealsStore = useDealsStore()

  const socket = io(config.public.socketUrl || 'http://localhost:5000', {
    autoConnect: false,
    reconnection: true,
    reconnectionAttempts: Infinity,
    reconnectionDelay: 1000,
    reconnectionDelayMax: 5000,
    randomizationFactor: 0.5,
  })

  nuxtApp.provide('socket', socket)

  if (process.client) {
    console.log('Connecting socket in plugin...')
    socket.connect()

    socket.on('connect', () => {
      console.log('Socket connected in plugin:', socket.id)
      if (authStore.isAuthenticated) {
        console.log('Joining room for user:', authStore.user.id)
        socket.emit('join', { userId: authStore.user.id })
      }
      notificationStore.setupSocketListeners(socket)
    })

    socket.on('connect_error', (error) => {
      console.error('Socket connection error in plugin:', error.message)
      // You can add additional error handling here, such as showing a toast message
    })

    socket.on('disconnect', (reason) => {
      console.log('Socket disconnected:', reason)
      if (reason === 'io server disconnect') {
        // The disconnection was initiated by the server, you need to reconnect manually
        socket.connect()
      }
      // Else the socket will automatically try to reconnect
    })

    // Listen for authentication changes
    watch(() => authStore.isAuthenticated, (isAuthenticated) => {
      if (isAuthenticated) {
        if (!socket.connected) {
          socket.connect()
        }
        console.log('User authenticated, joining room:', authStore.user.id)
        socket.emit('join', { userId: authStore.user.id })
      } else {
        if (socket.connected) {
          socket.disconnect()
        }
      }
    }, { immediate: true })

    socket.on('newNotification', (notification) => {
      console.log('Received new notification:', notification);
      notificationStore.handleNewNotification(notification);
    });

    socket.on('newDeal', (deal) => {
      console.log('Received new deal:', deal);
      dealsStore.addNewDeal(deal);
    });
  }
})

================
File: plugins/toast.js
================
import Toast from "vue-toastification";
import "vue-toastification/dist/index.css";

export default defineNuxtPlugin((nuxtApp) => {
  nuxtApp.vueApp.use(Toast, {
    // Toast options
  });
});

================
File: plugins/userAvatar.js
================
// plugins/userAvatar.js
import UserAvatar from '~/components/UserAvatar.vue'

export default defineNuxtPlugin((nuxtApp) => {
  nuxtApp.vueApp.component('UserAvatar', UserAvatar)
})

================
File: public/robots.txt
================


================
File: README.md
================
# Nuxt 3 Minimal Starter

Look at the [Nuxt 3 documentation](https://nuxt.com/docs/getting-started/introduction) to learn more.

## Setup

Make sure to install the dependencies:

```bash
# npm
npm install

# pnpm
pnpm install

# yarn
yarn install

# bun
bun install
```

## Development Server

Start the development server on `http://localhost:3000`:

```bash
# npm
npm run dev

# pnpm
pnpm run dev

# yarn
yarn dev

# bun
bun run dev
```

## Production

Build the application for production:

```bash
# npm
npm run build

# pnpm
pnpm run build

# yarn
yarn build

# bun
bun run build
```

Locally preview production build:

```bash
# npm
npm run preview

# pnpm
pnpm run preview

# yarn
yarn preview

# bun
bun run preview
```

Check out the [deployment documentation](https://nuxt.com/docs/getting-started/deployment) for more information.

================
File: server/tsconfig.json
================
{
  "extends": "../.nuxt/tsconfig.server.json"
}

================
File: services/api.js
================
// services/api.js
import axios from 'axios'

const api = axios.create({
  baseURL: 'http://localhost:5000/api/v1', // Adjust this to match your API URL
  headers: {
    'Content-Type': 'application/json',
  },
})

api.interceptors.request.use(config => {
  const token = localStorage.getItem('token')
  if (token) {
    config.headers['Authorization'] = `Bearer ${token}`
  }
  return config
})

export default api

================
File: stores/auth.js
================
import { defineStore } from 'pinia'
import api from '~/services/api'

export const useAuthStore = defineStore('auth', {
  state: () => ({
    user: null,
    token: null,
    tokenExpirationTime: null,
  }),

  getters: {
    isAuthenticated: (state) => !!state.token && state.tokenExpirationTime > Date.now(),
  },

  actions: {
    async initializeAuth() {
      if (process.client) {
        const token = localStorage.getItem('token')
        const tokenExpirationTime = localStorage.getItem('tokenExpirationTime')
        if (token && tokenExpirationTime) {
          this.token = token
          this.tokenExpirationTime = parseInt(tokenExpirationTime)
          if (this.isAuthenticated) {
            api.defaults.headers.common['Authorization'] = `Bearer ${token}`
            await this.fetchUser()
          } else {
            this.logout()
          }
        }
      }
    },

    async login(email, password) {
        try {
          const response = await api.post('/users/login', { email, password });
          if (response.data && response.data.token) {
            this.setAuthData(response.data);
            return true;
          } else {
            console.error('Invalid response from server:', response.data);
            return false;
          }
        } catch (error) {
          console.error('Login error:', error);
          if (error.response) {
            console.error('Error response:', error.response.data);
          }
          throw error;
        }
      },

      async signup(userData) {
        try {
          const response = await api.post('/users/register', userData);
          if (response.data && response.data.token) {
            this.setAuthData(response.data);
            return true;
          } else {
            console.error('Invalid response from server:', response.data);
            return false;
          }
        } catch (error) {
          console.error('Signup error:', error);
          if (error.response) {
            console.error('Error response:', error.response.data);
          }
          throw error;
        }
      },

    setAuthData(data) {
      this.token = data.token
      this.user = data.user || data.data?.user || null
      // Assume token expires in 1 hour (3600000 ms)
      this.tokenExpirationTime = Date.now() + 3600000
      if (process.client) {
        localStorage.setItem('token', this.token)
        localStorage.setItem('tokenExpirationTime', this.tokenExpirationTime.toString())
        api.defaults.headers.common['Authorization'] = `Bearer ${this.token}`
        this.setupTokenExpirationCheck()
      }
    },

    setupTokenExpirationCheck() {
      if (process.client) {
        const timeUntilExpiration = this.tokenExpirationTime - Date.now()
        setTimeout(() => {
          if (!this.isAuthenticated) {
            this.logout()
          }
        }, timeUntilExpiration)
      }
    },

    async fetchUser() {
      try {
        const response = await api.get('/users/me')
        this.user = response.data.data.user
        return this.user
      } catch (error) {
        console.error('Error fetching user:', error)
        if (error.response && error.response.status === 401) {
          // Token is invalid or expired
          this.logout()
        }
        throw error
      }
    },

    logout() {
      this.user = null
      this.token = null
      this.tokenExpirationTime = null
      if (process.client) {
        localStorage.removeItem('token')
        localStorage.removeItem('tokenExpirationTime')
        delete api.defaults.headers.common['Authorization']
        // Redirect to main page
        window.location.href = '/'
      }
    },
  },
})

================
File: stores/deals.js
================
import { defineStore } from 'pinia'
import api from '~/services/api'
import { useAuthStore } from '~/stores/auth' // Added import for useAuthStore

export const useDealsStore = defineStore('deals', {
  state: () => ({
    deals: [],
    userDeals: [],
    followedDeals: [],
    loading: false,
    error: null,
  }),

  getters: {
    getSortedDeals: (state) => {
      return [...state.deals].sort((a, b) => new Date(b.createdAt) - new Date(a.createdAt))
    },
    getDealById: (state) => (id) => {
      return state.deals.find(deal => deal._id === id)
    },
  },

  actions: {
    async fetchDeals() {
      this.loading = true
      this.error = null
      try {
        const response = await api.get('/deals')
        this.deals = response.data.data.deals || [] // Simplified to directly assign deals
        console.log('Fetched deals:', this.deals) // Added console log for fetched deals
      } catch (error) {
        console.error('Error fetching deals:', error)
        this.error = error.message || 'Failed to fetch deals'
      } finally {
        this.loading = false
      }
    },

    handleNewDeal(deal) {
      console.log('Handling new deal:', deal)
      const authStore = useAuthStore() // Moved authStore initialization here
      if (deal.user && deal.user._id === authStore.user?._id) { // Adjusted to check deal.user._id
        const index = this.deals.findIndex(d => d._id === deal._id)
        if (index !== -1) {
          // Update existing deal
          this.deals[index] = { ...this.deals[index], ...deal }
        } else {
          // Add new deal
          this.deals.unshift(deal)
        }
        
        // Update userDeals if necessary
        if (deal.user._id === this.getCurrentUserId()) {
          const userIndex = this.userDeals.findIndex(d => d._id === deal._id)
          if (userIndex !== -1) {
            this.userDeals[userIndex] = { ...this.userDeals[userIndex], ...deal }
          } else {
            this.userDeals.unshift(deal)
          }
        }
      }
      console.log('Updated deals:', this.deals)
    },

    async fetchUserDeals() {
      try {
        const response = await api.get('/users/me/deals')
        this.userDeals = response.data.data.deals || []
      } catch (error) {
        console.error('Error fetching user deals:', error)
        throw error
      }
    },

    async fetchFollowedDeals() {
      try {
        const response = await api.get('/users/me/followed-deals')
        this.followedDeals = response.data.data.followedDeals || []
      } catch (error) {
        console.error('Error fetching followed deals:', error)
        throw error
      }
    },

    async postDeal(dealData) {
      try {
        const response = await api.post('/deals', dealData)
        const newDeal = response.data.data.deal
        this.handleNewDeal(newDeal)
        return newDeal
      } catch (error) {
        console.error('Error posting deal:', error)
        throw error
      }
    },

    mergeDeals(existingDeals, newDeals) {
      const mergedDeals = [...existingDeals]
      newDeals.forEach(newDeal => {
        const existingIndex = mergedDeals.findIndex(d => d._id === newDeal._id)
        if (existingIndex !== -1) {
          mergedDeals[existingIndex] = { ...mergedDeals[existingIndex], ...newDeal }
        } else {
          mergedDeals.push(newDeal)
        }
      })
      return mergedDeals.sort((a, b) => new Date(b.createdAt) - new Date(a.createdAt))
    },

    getCurrentUserId() {
      // Implement this method to get the current user's ID from your auth store
      const authStore = useAuthStore()
      return authStore.user ? authStore.user._id : null
    },

    // Other actions (followDeal, unfollowDeal, etc.) remain the same
  },
})

================
File: stores/notification.js
================
// stores/notification.js
import { defineStore } from 'pinia'
import api from '../services/api'

export const useNotificationStore = defineStore('notification', {
  state: () => ({
    notifications: [],
  }),

  actions: {
    addNotification(notification) {
      console.log('Adding notification:', notification)
      this.notifications.unshift(notification)
    },
    markAsRead(notificationId) {
      const notification = this.notifications.find(n => n._id === notificationId)
      if (notification) {
        notification.read = true
      }
    },
    setNotifications(notifications) {
      console.log('Setting notifications:', notifications)
      this.notifications = notifications || []
    },
    async fetchNotifications() {
      try {
        const { data } = await api.get('/users/notifications')
        console.log('Fetched notifications:', data)
        this.setNotifications(data.data.notifications)
      } catch (error) {
        console.error('Error fetching notifications:', error)
        this.setNotifications([])
      }
    },
    async markNotificationAsRead(notificationId) {
      try {
        await api.patch(`/users/notifications/${notificationId}/read`)
        this.markAsRead(notificationId)
      } catch (error) {
        console.error('Error marking notification as read:', error)
      }
    },
    clearNotifications() {
      this.notifications = []
    },
    handleNewNotification(notification) {
      console.log('Handling new notification in store:', notification);
      this.addNotification(notification);
    },
    setupSocketListeners(socket) {
      console.log('Setting up socket listeners for notifications')
      socket.on('newNotification', (notification) => {
        console.log('Received new notification:', notification)
        this.addNotification(notification)
      })
    },
  },

  getters: {
    unreadCount: (state) => state.notifications.filter(n => !n.read).length,
    sortedNotifications: (state) => [...state.notifications].sort((a, b) => new Date(b.createdAt) - new Date(a.createdAt))
  }
})

================
File: tailwind.config.js
================
module.exports = {
  content: [
    './components/**/*.{js,vue,ts}',
    './layouts/**/*.vue',
    './pages/**/*.vue',
    './plugins/**/*.{js,ts}',
    './nuxt.config.{js,ts}',
  ],
  theme: {
    extend: {
      fontFamily: {
        sans: ['Inter', 'sans-serif'],
        heading: ['Montserrat', 'sans-serif'],
      },
      colors: {
        primary: '#3498db',
        secondary: '#2ecc71',
        accent: '#e74c3c',
        background: '#f8fafc',
        text: '#2d3748',
      },
    },
  },
  plugins: [],
}

================
File: tsconfig.json
================
{
  // https://nuxt.com/docs/guide/concepts/typescript
  "extends": "./.nuxt/tsconfig.json"
}
